'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const NUM = '\\d+';
const SDP_TOKEN = "[!#$%&'*+\\-.^_`{|}~a-zA-Z0-9]+";
const ANY_NON_WS = '\\S+';
const SP = '\\s';
const WS = '\\w*';
const REST = '.+';

class Line {
}

var _a$5;
class BandwidthLine extends Line {
    constructor(bandwidthType, bandwidth) {
        super();
        this.bandwidthType = bandwidthType;
        this.bandwidth = bandwidth;
    }
    static fromSdpLine(line) {
        if (!BandwidthLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(BandwidthLine.regex);
        const bandwidthType = tokens[1];
        const bandwidth = parseInt(tokens[2], 10);
        return new BandwidthLine(bandwidthType, bandwidth);
    }
    toSdpLine() {
        return `b=${this.bandwidthType}:${this.bandwidth}`;
    }
}
_a$5 = BandwidthLine;
BandwidthLine.BW_TYPE_REGEX = 'CT|AS|TIAS';
BandwidthLine.regex = new RegExp(`^(${_a$5.BW_TYPE_REGEX}):(${NUM})`);

class BundleGroupLine extends Line {
    constructor(mids) {
        super();
        this.mids = mids;
    }
    static fromSdpLine(line) {
        if (!BundleGroupLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(BundleGroupLine.regex);
        const mids = tokens[1].split(' ');
        return new BundleGroupLine(mids);
    }
    toSdpLine() {
        return `a=group:BUNDLE ${this.mids.join(' ')}`;
    }
}
BundleGroupLine.regex = new RegExp(`^group:BUNDLE (${REST})`);

var _a$4;
class CandidateLine extends Line {
    constructor(foundation, componentId, transport, priority, connectionAddress, port, candidateType, relAddr, relPort, candidateExtensions) {
        super();
        this.foundation = foundation;
        this.componentId = componentId;
        this.transport = transport;
        this.priority = priority;
        this.connectionAddress = connectionAddress;
        this.port = port;
        this.candidateType = candidateType;
        this.relAddr = relAddr;
        this.relPort = relPort;
        this.candidateExtensions = candidateExtensions;
    }
    static fromSdpLine(line) {
        if (!CandidateLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(CandidateLine.regex);
        const foundation = tokens[1];
        const componentId = parseInt(tokens[2], 10);
        const transport = tokens[3];
        const priority = parseInt(tokens[4], 10);
        const connectionAddress = tokens[5];
        const port = parseInt(tokens[6], 10);
        const candidateType = tokens[7];
        const relAddr = tokens[8];
        const relPort = tokens[9] ? parseInt(tokens[9], 10) : undefined;
        const candidateExtensions = tokens[10];
        return new CandidateLine(foundation, componentId, transport, priority, connectionAddress, port, candidateType, relAddr, relPort, candidateExtensions);
    }
    toSdpLine() {
        let str = '';
        str += `a=candidate:${this.foundation} ${this.componentId} ${this.transport} ${this.priority} ${this.connectionAddress} ${this.port} typ ${this.candidateType}`;
        if (this.relAddr) {
            str += ` raddr ${this.relAddr}`;
        }
        if (this.relPort) {
            str += ` rport ${this.relPort}`;
        }
        if (this.candidateExtensions) {
            str += ` ${this.candidateExtensions}`;
        }
        return str;
    }
}
_a$4 = CandidateLine;
CandidateLine.ICE_CHARS = `[a-zA-Z0-9+/]+`;
CandidateLine.regex = new RegExp(`^candidate:(${_a$4.ICE_CHARS}) (${NUM}) (${ANY_NON_WS}) (${NUM}) (${ANY_NON_WS}) (${NUM}) typ (${ANY_NON_WS})(?: raddr (${ANY_NON_WS}))?(?: rport (${NUM}))?(?: (${REST}))?`);

class ConnectionLine extends Line {
    constructor(netType, addrType, ipAddr) {
        super();
        this.netType = netType;
        this.addrType = addrType;
        this.ipAddr = ipAddr;
    }
    static fromSdpLine(line) {
        if (!ConnectionLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(ConnectionLine.regex);
        const netType = tokens[1];
        const addrType = tokens[2];
        const ipAddr = tokens[3];
        return new ConnectionLine(netType, addrType, ipAddr);
    }
    toSdpLine() {
        return `c=${this.netType} ${this.addrType} ${this.ipAddr}`;
    }
}
ConnectionLine.regex = new RegExp(`^(${ANY_NON_WS}) (${ANY_NON_WS}) (${ANY_NON_WS})`);

class ContentLine extends Line {
    constructor(values) {
        super();
        this.values = values;
    }
    static fromSdpLine(line) {
        if (!ContentLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(ContentLine.regex);
        const values = tokens[1].split(',');
        return new ContentLine(values);
    }
    toSdpLine() {
        return `a=content:${this.values.join(',')}`;
    }
}
ContentLine.regex = new RegExp(`^content:(${REST})$`);

class DirectionLine extends Line {
    constructor(direction) {
        super();
        this.direction = direction;
    }
    static fromSdpLine(line) {
        if (!DirectionLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(DirectionLine.regex);
        const direction = tokens[1];
        return new DirectionLine(direction);
    }
    toSdpLine() {
        return `a=${this.direction}`;
    }
}
DirectionLine.regex = /^(sendrecv|sendonly|recvonly|inactive)$/;

var _a$3;
class ExtMapLine extends Line {
    constructor(id, uri, direction, extensionAttributes) {
        super();
        this.id = id;
        this.uri = uri;
        this.direction = direction;
        this.extensionAttributes = extensionAttributes;
    }
    static fromSdpLine(line) {
        if (!ExtMapLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(ExtMapLine.regex);
        const id = parseInt(tokens[1], 10);
        const direction = tokens[2];
        const uri = tokens[3];
        const extensionAttributes = tokens[4];
        return new ExtMapLine(id, uri, direction, extensionAttributes);
    }
    toSdpLine() {
        let str = '';
        str += `a=extmap:${this.id}`;
        if (this.direction) {
            str += `/${this.direction}`;
        }
        str += ` ${this.uri}`;
        if (this.extensionAttributes) {
            str += ` ${this.extensionAttributes}`;
        }
        return str;
    }
}
_a$3 = ExtMapLine;
ExtMapLine.EXTMAP_DIRECTION = `sendonly|recvonly|sendrecv|inactive`;
ExtMapLine.regex = new RegExp(`^extmap:(${NUM})(?:/(${_a$3.EXTMAP_DIRECTION}))? (${ANY_NON_WS})(?: (${REST}))?`);

class FingerprintLine extends Line {
    constructor(fingerprint) {
        super();
        this.fingerprint = fingerprint;
    }
    static fromSdpLine(line) {
        if (!FingerprintLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(FingerprintLine.regex);
        const fingerprint = tokens[1];
        return new FingerprintLine(fingerprint);
    }
    toSdpLine() {
        return `a=fingerprint:${this.fingerprint}`;
    }
}
FingerprintLine.regex = new RegExp(`^fingerprint:(${REST})`);

function parseFmtpParams(fmtpParams) {
    fmtpParams = fmtpParams.replace(/^a=fmtp:\d+\x20/, '');
    const fmtpObj = new Map();
    if (/^\d+([/-]\d+)+$/.test(fmtpParams)) {
        fmtpObj.set(fmtpParams, undefined);
        return fmtpObj;
    }
    fmtpParams.split(';').forEach((param) => {
        const paramArr = param && param.split('=');
        if (paramArr.length !== 2 || !paramArr[0] || !paramArr[1]) {
            throw new Error(`Fmtp params is invalid with ${fmtpParams}`);
        }
        fmtpObj.set(paramArr[0], paramArr[1]);
    });
    return fmtpObj;
}
class FmtpLine extends Line {
    constructor(payloadType, params) {
        super();
        this.payloadType = payloadType;
        this.params = params;
    }
    static fromSdpLine(line) {
        if (!FmtpLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(FmtpLine.regex);
        const payloadType = parseInt(tokens[1], 10);
        const params = tokens[2];
        return new FmtpLine(payloadType, parseFmtpParams(params));
    }
    toSdpLine() {
        const fmtParams = Array.from(this.params.keys())
            .map((key) => {
            if (this.params.get(key) !== undefined) {
                return `${key}=${this.params.get(key)}`;
            }
            return `${key}`;
        })
            .join(';');
        return `a=fmtp:${this.payloadType} ${fmtParams}`;
    }
}
FmtpLine.regex = new RegExp(`^fmtp:(${NUM}) (${REST})`);

class IceOptionsLine extends Line {
    constructor(options) {
        super();
        this.options = options;
    }
    static fromSdpLine(line) {
        if (!IceOptionsLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(IceOptionsLine.regex);
        const options = tokens[1].split(' ');
        return new IceOptionsLine(options);
    }
    toSdpLine() {
        return `a=ice-options:${this.options.join(' ')}`;
    }
}
IceOptionsLine.regex = new RegExp(`^ice-options:(${REST})$`);

class IcePwdLine extends Line {
    constructor(pwd) {
        super();
        this.pwd = pwd;
    }
    static fromSdpLine(line) {
        if (!IcePwdLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(IcePwdLine.regex);
        const pwd = tokens[1];
        return new IcePwdLine(pwd);
    }
    toSdpLine() {
        return `a=ice-pwd:${this.pwd}`;
    }
}
IcePwdLine.regex = new RegExp(`^ice-pwd:(${ANY_NON_WS})$`);

class IceUfragLine extends Line {
    constructor(ufrag) {
        super();
        this.ufrag = ufrag;
    }
    static fromSdpLine(line) {
        if (!IceUfragLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(IceUfragLine.regex);
        const ufrag = tokens[1];
        return new IceUfragLine(ufrag);
    }
    toSdpLine() {
        return `a=ice-ufrag:${this.ufrag}`;
    }
}
IceUfragLine.regex = new RegExp(`^ice-ufrag:(${ANY_NON_WS})$`);

class MaxMessageSizeLine extends Line {
    constructor(maxMessageSize) {
        super();
        this.maxMessageSize = maxMessageSize;
    }
    static fromSdpLine(line) {
        if (!MaxMessageSizeLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(MaxMessageSizeLine.regex);
        const maxMessageSize = parseInt(tokens[1], 10);
        return new MaxMessageSizeLine(maxMessageSize);
    }
    toSdpLine() {
        return `a=max-message-size:${this.maxMessageSize}`;
    }
}
MaxMessageSizeLine.regex = new RegExp(`^max-message-size:(${NUM})`);

var _a$2;
class MediaLine extends Line {
    constructor(type, port, protocol, formats) {
        super();
        this.type = type;
        this.port = port;
        this.protocol = protocol;
        this.formats = formats;
    }
    static fromSdpLine(line) {
        if (!MediaLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(MediaLine.regex);
        const type = tokens[1];
        const port = parseInt(tokens[2], 10);
        const protocol = tokens[3];
        const formats = tokens[4].split(' ');
        return new MediaLine(type, port, protocol, formats);
    }
    toSdpLine() {
        return `m=${this.type} ${this.port} ${this.protocol} ${this.formats.join(' ')}`;
    }
}
_a$2 = MediaLine;
MediaLine.MEDIA_TYPE = 'audio|video|application';
MediaLine.regex = new RegExp(`^(${_a$2.MEDIA_TYPE}) (${NUM}) (${ANY_NON_WS}) (${REST})`);

class MidLine extends Line {
    constructor(mid) {
        super();
        this.mid = mid;
    }
    static fromSdpLine(line) {
        if (!MidLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(MidLine.regex);
        const mid = tokens[1];
        return new MidLine(mid);
    }
    toSdpLine() {
        return `a=mid:${this.mid}`;
    }
}
MidLine.regex = new RegExp(`^mid:(${ANY_NON_WS})$`);

class OriginLine extends Line {
    constructor(username, sessionId, sessionVersion, netType, addrType, ipAddr) {
        super();
        this.username = username;
        this.sessionId = sessionId;
        this.sessionVersion = sessionVersion;
        this.netType = netType;
        this.addrType = addrType;
        this.ipAddr = ipAddr;
    }
    static fromSdpLine(line) {
        if (!OriginLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(OriginLine.regex);
        const username = tokens[1];
        const sessionId = tokens[2];
        const sessionVersion = parseInt(tokens[3], 10);
        const netType = tokens[4];
        const addrType = tokens[5];
        const ipAddr = tokens[6];
        return new OriginLine(username, sessionId, sessionVersion, netType, addrType, ipAddr);
    }
    toSdpLine() {
        return `o=${this.username} ${this.sessionId} ${this.sessionVersion} ${this.netType} ${this.addrType} ${this.ipAddr}`;
    }
}
OriginLine.regex = new RegExp(`^(${ANY_NON_WS}) (${ANY_NON_WS}) (${NUM}) (${ANY_NON_WS}) (${ANY_NON_WS}) (${ANY_NON_WS})`);

var _a$1;
class RidLine extends Line {
    constructor(id, direction, params) {
        super();
        this.id = id;
        this.direction = direction;
        this.params = params;
    }
    static fromSdpLine(line) {
        if (!RidLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(RidLine.regex);
        const id = tokens[1];
        const direction = tokens[2];
        const params = tokens[3];
        return new RidLine(id, direction, params);
    }
    toSdpLine() {
        let str = '';
        str += `a=rid:${this.id} ${this.direction}`;
        if (this.params) {
            str += ` ${this.params}`;
        }
        return str;
    }
}
_a$1 = RidLine;
RidLine.RID_ID = `[\\w-]+`;
RidLine.RID_DIRECTION = `\\bsend\\b|\\brecv\\b`;
RidLine.regex = new RegExp(`^rid:(${_a$1.RID_ID}) (${_a$1.RID_DIRECTION})(?:${SP}(${REST}))?`);

class RtcpMuxLine extends Line {
    static fromSdpLine(line) {
        if (!RtcpMuxLine.regex.test(line)) {
            return undefined;
        }
        return new RtcpMuxLine();
    }
    toSdpLine() {
        return `a=rtcp-mux`;
    }
}
RtcpMuxLine.regex = /^rtcp-mux$/;

class RtcpFbLine extends Line {
    constructor(payloadType, feedback) {
        super();
        this.payloadType = payloadType;
        this.feedback = feedback;
    }
    static fromSdpLine(line) {
        if (!RtcpFbLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(RtcpFbLine.regex);
        const payloadType = parseInt(tokens[1], 10);
        const feedback = tokens[2];
        return new RtcpFbLine(payloadType, feedback);
    }
    toSdpLine() {
        return `a=rtcp-fb:${this.payloadType} ${this.feedback}`;
    }
}
RtcpFbLine.regex = new RegExp(`^rtcp-fb:(${NUM}) (${REST})`);

var _a;
class RtpMapLine extends Line {
    constructor(payloadType, encodingName, clockRate, encodingParams) {
        super();
        this.payloadType = payloadType;
        this.encodingName = encodingName;
        this.clockRate = clockRate;
        this.encodingParams = encodingParams;
    }
    static fromSdpLine(line) {
        if (!RtpMapLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(RtpMapLine.regex);
        const payloadType = parseInt(tokens[1], 10);
        const encodingName = tokens[2];
        const clockRate = parseInt(tokens[3], 10);
        const encodingParams = tokens[4];
        return new RtpMapLine(payloadType, encodingName, clockRate, encodingParams);
    }
    toSdpLine() {
        let str = '';
        str += `a=rtpmap:${this.payloadType} ${this.encodingName}/${this.clockRate}`;
        if (this.encodingParams) {
            str += `/${this.encodingParams}`;
        }
        return str;
    }
}
_a = RtpMapLine;
RtpMapLine.NON_SLASH_TOKEN = '[^\\s/]+';
RtpMapLine.regex = new RegExp(`^rtpmap:(${NUM}) (${_a.NON_SLASH_TOKEN})/(${_a.NON_SLASH_TOKEN})(?:/(${_a.NON_SLASH_TOKEN}))?`);

class SctpPortLine extends Line {
    constructor(port) {
        super();
        this.port = port;
    }
    static fromSdpLine(line) {
        if (!SctpPortLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SctpPortLine.regex);
        const port = parseInt(tokens[1], 10);
        return new SctpPortLine(port);
    }
    toSdpLine() {
        return `a=sctp-port:${this.port}`;
    }
}
SctpPortLine.regex = new RegExp(`^sctp-port:(${NUM})`);

class SessionInformationLine extends Line {
    constructor(info) {
        super();
        this.info = info;
    }
    static fromSdpLine(line) {
        if (!SessionInformationLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SessionInformationLine.regex);
        const info = tokens[1];
        return new SessionInformationLine(info);
    }
    toSdpLine() {
        return `i=${this.info}`;
    }
}
SessionInformationLine.regex = new RegExp(`(${REST})`);

class SessionNameLine extends Line {
    constructor(name) {
        super();
        this.name = name;
    }
    static fromSdpLine(line) {
        if (!SessionNameLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SessionNameLine.regex);
        const name = tokens[1];
        return new SessionNameLine(name);
    }
    toSdpLine() {
        return `s=${this.name}`;
    }
}
SessionNameLine.regex = new RegExp(`^(${REST})`);

class SetupLine extends Line {
    constructor(setup) {
        super();
        this.setup = setup;
    }
    static fromSdpLine(line) {
        if (!SetupLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SetupLine.regex);
        const setup = tokens[1];
        return new SetupLine(setup);
    }
    toSdpLine() {
        return `a=setup:${this.setup}`;
    }
}
SetupLine.regex = /^setup:(actpass|active|passive)$/;

class SimulcastLayer {
    constructor(id, paused) {
        this.id = id;
        this.paused = paused;
    }
    toString() {
        return this.paused ? `~${this.id}` : this.id;
    }
}
class SimulcastLayerList {
    constructor() {
        this.layers = [];
    }
    addLayer(layer) {
        this.layers.push([layer]);
    }
    addLayerWithAlternatives(alternatives) {
        this.layers.push(alternatives);
    }
    get length() {
        return this.layers.length;
    }
    get(index) {
        return this.layers[index];
    }
    static fromString(str) {
        const layerList = new SimulcastLayerList();
        const tokens = str.split(';');
        if (tokens.length === 1 && !tokens[0].trim()) {
            throw new Error('simulcast stream list empty');
        }
        tokens.forEach((token) => {
            if (!token) {
                throw new Error('simulcast layer list empty');
            }
            const ridTokens = token.split(',');
            const layers = [];
            ridTokens.forEach((ridToken) => {
                if (!ridToken || ridToken === '~') {
                    throw new Error('rid empty');
                }
                const paused = ridToken[0] === '~';
                const rid = paused ? ridToken.substring(1) : ridToken;
                layers.push(new SimulcastLayer(rid, paused));
            });
            layerList.addLayerWithAlternatives(layers);
        });
        return layerList;
    }
    toString() {
        return this.layers
            .map((altArray) => altArray.map((v) => v.toString()).join(','))
            .join(';');
    }
}
class SimulcastLine extends Line {
    constructor(sendLayers, recvLayers) {
        super();
        this.sendLayers = sendLayers;
        this.recvLayers = recvLayers;
    }
    static fromSdpLine(line) {
        if (!SimulcastLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SimulcastLine.regex);
        const bidirectional = tokens[3] && tokens[4];
        const firstDirection = tokens[1];
        const layerList1 = SimulcastLayerList.fromString(tokens[2]);
        let layerList2 = new SimulcastLayerList();
        if (bidirectional) {
            const secondDirection = tokens[3];
            if (firstDirection === secondDirection) {
                return undefined;
            }
            layerList2 = SimulcastLayerList.fromString(tokens[4]);
        }
        let sendLayerList;
        let recvLayerList;
        if (firstDirection === 'send') {
            sendLayerList = layerList1;
            recvLayerList = layerList2;
        }
        else {
            sendLayerList = layerList2;
            recvLayerList = layerList1;
        }
        return new SimulcastLine(sendLayerList, recvLayerList);
    }
    toSdpLine() {
        let str = 'a=simulcast:';
        if (this.sendLayers.length) {
            str += `send ${this.sendLayers.toString()}`;
            if (this.recvLayers.length) {
                str += ` `;
            }
        }
        if (this.recvLayers.length) {
            str += `recv ${this.recvLayers.toString()}`;
        }
        return str;
    }
}
SimulcastLine.regex = new RegExp(`^simulcast:(send|recv) (${ANY_NON_WS})(?: (send|recv) (${ANY_NON_WS}))?`);

class SsrcLine extends Line {
    constructor(ssrcId, attribute, attributeValue = undefined, attributeData = undefined) {
        super();
        this.ssrcId = ssrcId;
        this.attribute = attribute;
        this.attributeValue = attributeValue;
        this.attributeData = attributeData;
    }
    static fromSdpLine(line) {
        if (!SsrcLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SsrcLine.regex);
        const ssrcId = parseInt(tokens[1], 10);
        const attribute = tokens[2];
        const attributeValue = tokens[3];
        const attributeData = tokens[4];
        return new SsrcLine(ssrcId, attribute, attributeValue, attributeData);
    }
    toSdpLine() {
        let str = `a=ssrc:${this.ssrcId} ${this.attribute}`;
        if (this.attributeValue) {
            str += `:${this.attributeValue}`;
        }
        if (this.attributeData) {
            str += ` ${this.attributeData}`;
        }
        return str;
    }
}
SsrcLine.regex = new RegExp(`^ssrc:(${NUM}) (${SDP_TOKEN})(?::(${SDP_TOKEN})?(?: (${ANY_NON_WS}))?)?$`);

class SsrcGroupLine extends Line {
    constructor(semantics, ssrcs) {
        super();
        this.semantics = semantics;
        this.ssrcs = ssrcs;
    }
    static fromSdpLine(line) {
        if (!SsrcGroupLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(SsrcGroupLine.regex);
        const semantics = tokens[1];
        const ssrcs = tokens[2].split(' ').map((ssrcStr) => parseInt(ssrcStr, 10));
        return new SsrcGroupLine(semantics, ssrcs);
    }
    toSdpLine() {
        return `a=ssrc-group:${this.semantics} ${this.ssrcs.join(' ')}`;
    }
}
SsrcGroupLine.regex = new RegExp(`^ssrc-group:(SIM|FID|FEC) ((?:${NUM}${SP}*)+)`);

class TimingLine extends Line {
    constructor(startTime, stopTime) {
        super();
        this.startTime = startTime;
        this.stopTime = stopTime;
    }
    static fromSdpLine(line) {
        if (!TimingLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(TimingLine.regex);
        const startTime = parseInt(tokens[1], 10);
        const stopTime = parseInt(tokens[2], 10);
        return new TimingLine(startTime, stopTime);
    }
    toSdpLine() {
        return `t=${this.startTime} ${this.stopTime}`;
    }
}
TimingLine.regex = new RegExp(`^(${NUM}) (${NUM})`);

class VersionLine extends Line {
    constructor(version) {
        super();
        this.version = version;
    }
    static fromSdpLine(line) {
        if (!VersionLine.regex.test(line)) {
            return undefined;
        }
        const tokens = line.match(VersionLine.regex);
        const version = parseInt(tokens[1], 10);
        return new VersionLine(version);
    }
    toSdpLine() {
        return `v=${this.version}`;
    }
}
VersionLine.regex = new RegExp(`^(${NUM})$`);

class UnknownLine extends Line {
    constructor(value) {
        super();
        this.value = value;
    }
    static fromSdpLine(line) {
        const tokens = line.match(UnknownLine.regex);
        const value = tokens[1];
        return new UnknownLine(value);
    }
    toSdpLine() {
        return `${this.value}`;
    }
}
UnknownLine.regex = new RegExp(`(${REST})`);

class IceInfo {
    constructor() {
        this.candidates = [];
    }
    addLine(line) {
        if (line instanceof IceUfragLine) {
            this.ufrag = line;
            return true;
        }
        if (line instanceof IcePwdLine) {
            this.pwd = line;
            return true;
        }
        if (line instanceof IceOptionsLine) {
            this.options = line;
            return true;
        }
        if (line instanceof CandidateLine) {
            this.candidates.push(line);
            return true;
        }
        return false;
    }
    toLines() {
        const lines = [];
        if (this.ufrag) {
            lines.push(this.ufrag);
        }
        if (this.pwd) {
            lines.push(this.pwd);
        }
        if (this.options) {
            lines.push(this.options);
        }
        this.candidates.forEach((candidate) => lines.push(candidate));
        return lines;
    }
}

class MediaDescription {
    constructor(type, port, protocol) {
        this.iceInfo = new IceInfo();
        this.otherLines = [];
        this.type = type;
        this.port = port;
        this.protocol = protocol;
    }
    findOtherLine(ty) {
        return this.otherLines.find((line) => line instanceof ty);
    }
    addLine(line) {
        if (line instanceof BundleGroupLine) {
            throw new Error(`Error: bundle group line not allowed in media description`);
        }
        if (line instanceof BandwidthLine) {
            this.bandwidth = line;
            return true;
        }
        if (line instanceof MidLine) {
            this.mid = line.mid;
            return true;
        }
        if (line instanceof FingerprintLine) {
            this.fingerprint = line.fingerprint;
            return true;
        }
        if (line instanceof SetupLine) {
            this.setup = line.setup;
            return true;
        }
        if (line instanceof ConnectionLine) {
            this.connection = line;
            return true;
        }
        if (line instanceof ContentLine) {
            this.content = line;
            return true;
        }
        return this.iceInfo.addLine(line);
    }
}

class ApplicationMediaDescription extends MediaDescription {
    constructor(mediaLine) {
        super(mediaLine.type, mediaLine.port, mediaLine.protocol);
        this.fmts = [];
        this.fmts = mediaLine.formats;
    }
    toLines() {
        const lines = [];
        lines.push(new MediaLine(this.type, this.port, this.protocol, this.fmts));
        if (this.connection) {
            lines.push(this.connection);
        }
        if (this.bandwidth) {
            lines.push(this.bandwidth);
        }
        lines.push(...this.iceInfo.toLines());
        if (this.fingerprint) {
            lines.push(new FingerprintLine(this.fingerprint));
        }
        if (this.setup) {
            lines.push(new SetupLine(this.setup));
        }
        if (this.mid) {
            lines.push(new MidLine(this.mid));
        }
        if (this.content) {
            lines.push(this.content);
        }
        if (this.sctpPort) {
            lines.push(new SctpPortLine(this.sctpPort));
        }
        if (this.maxMessageSize) {
            lines.push(new MaxMessageSizeLine(this.maxMessageSize));
        }
        lines.push(...this.otherLines);
        return lines;
    }
    addLine(line) {
        if (super.addLine(line)) {
            return true;
        }
        if (line instanceof MediaLine) {
            throw new Error('Error: tried passing a MediaLine to an existing MediaInfo');
        }
        if (line instanceof SctpPortLine) {
            this.sctpPort = line.port;
            return true;
        }
        if (line instanceof MaxMessageSizeLine) {
            this.maxMessageSize = line.maxMessageSize;
            return true;
        }
        this.otherLines.push(line);
        return true;
    }
}

class CodecInfo {
    constructor(pt) {
        this.fmtParams = new Map();
        this.feedback = [];
        this.pt = pt;
    }
    addLine(line) {
        if (line instanceof RtpMapLine) {
            this.name = line.encodingName;
            this.clockRate = line.clockRate;
            this.encodingParams = line.encodingParams;
            return true;
        }
        if (line instanceof FmtpLine) {
            this.fmtParams = new Map([
                ...Array.from(this.fmtParams.entries()),
                ...Array.from(line.params.entries()),
            ]);
            if (line.params.has('apt')) {
                const apt = line.params.get('apt');
                this.primaryCodecPt = parseInt(apt, 10);
            }
            return true;
        }
        if (line instanceof RtcpFbLine) {
            this.feedback.push(line.feedback);
            return true;
        }
        return false;
    }
    toLines() {
        const lines = [];
        lines.push(new RtpMapLine(this.pt, this.name, this.clockRate, this.encodingParams));
        this.feedback.forEach((fb) => {
            lines.push(new RtcpFbLine(this.pt, fb));
        });
        if (this.fmtParams.size > 0) {
            lines.push(new FmtpLine(this.pt, this.fmtParams));
        }
        return lines;
    }
}

class AvMediaDescription extends MediaDescription {
    constructor(mediaLine) {
        super(mediaLine.type, mediaLine.port, mediaLine.protocol);
        this.pts = [];
        this.extMaps = [];
        this.rids = [];
        this.codecs = new Map();
        this.rtcpMux = false;
        this.ssrcs = [];
        this.ssrcGroups = [];
        this.pts = mediaLine.formats.map((fmt) => {
            return parseInt(fmt, 10);
        });
        this.pts.forEach((pt) => this.codecs.set(pt, new CodecInfo(pt)));
    }
    toLines() {
        const lines = [];
        lines.push(new MediaLine(this.type, this.port, this.protocol, this.pts.map((pt) => `${pt}`)));
        if (this.connection) {
            lines.push(this.connection);
        }
        if (this.bandwidth) {
            lines.push(this.bandwidth);
        }
        lines.push(...this.iceInfo.toLines());
        if (this.fingerprint) {
            lines.push(new FingerprintLine(this.fingerprint));
        }
        if (this.setup) {
            lines.push(new SetupLine(this.setup));
        }
        if (this.mid) {
            lines.push(new MidLine(this.mid));
        }
        if (this.rtcpMux) {
            lines.push(new RtcpMuxLine());
        }
        if (this.content) {
            lines.push(this.content);
        }
        this.extMaps.forEach((extMap) => lines.push(extMap));
        this.rids.forEach((rid) => lines.push(rid));
        if (this.simulcast) {
            lines.push(this.simulcast);
        }
        if (this.direction) {
            lines.push(new DirectionLine(this.direction));
        }
        this.codecs.forEach((codec) => lines.push(...codec.toLines()));
        lines.push(...this.ssrcs);
        lines.push(...this.ssrcGroups);
        lines.push(...this.otherLines);
        return lines;
    }
    addLine(line) {
        if (super.addLine(line)) {
            return true;
        }
        if (line instanceof MediaLine) {
            throw new Error('Error: tried passing a MediaLine to an existing MediaInfo');
        }
        if (line instanceof DirectionLine) {
            this.direction = line.direction;
            return true;
        }
        if (line instanceof ExtMapLine) {
            this.extMaps.push(line);
            return true;
        }
        if (line instanceof RidLine) {
            this.rids.push(line);
            return true;
        }
        if (line instanceof RtcpMuxLine) {
            this.rtcpMux = true;
            return true;
        }
        if (line instanceof SimulcastLine) {
            this.simulcast = line;
            return true;
        }
        if (line instanceof RtpMapLine || line instanceof FmtpLine || line instanceof RtcpFbLine) {
            const codec = this.codecs.get(line.payloadType);
            if (!codec) {
                throw new Error(`Error: got line for unknown codec: ${line.toSdpLine()}`);
            }
            codec.addLine(line);
            return true;
        }
        if (line instanceof SsrcLine) {
            this.ssrcs.push(line);
            return true;
        }
        if (line instanceof SsrcGroupLine) {
            this.ssrcGroups.push(line);
            return true;
        }
        this.otherLines.push(line);
        return true;
    }
    getCodecByPt(pt) {
        return this.codecs.get(pt);
    }
    removePt(pt) {
        const associatedPts = [...this.codecs.values()]
            .filter((ci) => ci.primaryCodecPt === pt)
            .map((ci) => ci.pt);
        const allPtsToRemove = [pt, ...associatedPts];
        allPtsToRemove.forEach((ptToRemove) => {
            this.codecs.delete(ptToRemove);
        });
        this.pts = this.pts.filter((existingPt) => allPtsToRemove.indexOf(existingPt) === -1);
    }
}

class SessionDescription {
    constructor() {
        this.groups = [];
        this.otherLines = [];
    }
    addLine(line) {
        if (line instanceof VersionLine) {
            this.version = line;
            return true;
        }
        if (line instanceof OriginLine) {
            this.origin = line;
            return true;
        }
        if (line instanceof SessionNameLine) {
            this.sessionName = line;
            return true;
        }
        if (line instanceof SessionInformationLine) {
            this.information = line;
            return true;
        }
        if (line instanceof TimingLine) {
            this.timing = line;
            return true;
        }
        if (line instanceof ConnectionLine) {
            this.connection = line;
            return true;
        }
        if (line instanceof BandwidthLine) {
            this.bandwidth = line;
            return true;
        }
        if (line instanceof BundleGroupLine) {
            this.groups.push(line);
            return true;
        }
        this.otherLines.push(line);
        return true;
    }
    toLines() {
        const lines = [];
        if (this.version) {
            lines.push(this.version);
        }
        if (this.origin) {
            lines.push(this.origin);
        }
        if (this.sessionName) {
            lines.push(this.sessionName);
        }
        if (this.information) {
            lines.push(this.information);
        }
        if (this.connection) {
            lines.push(this.connection);
        }
        if (this.bandwidth) {
            lines.push(this.bandwidth);
        }
        if (this.timing) {
            lines.push(this.timing);
        }
        if (this.groups) {
            lines.push(...this.groups);
        }
        lines.push(...this.otherLines);
        return lines;
    }
}

class Sdp {
    constructor() {
        this.session = new SessionDescription();
        this.media = [];
    }
    get avMedia() {
        return this.media.filter((mi) => mi instanceof AvMediaDescription);
    }
    toString() {
        const lines = [];
        lines.push(...this.session.toLines());
        this.media.forEach((m) => lines.push(...m.toLines()));
        return `${lines.map((l) => l.toSdpLine()).join('\r\n')}\r\n`;
    }
}

class Grammar {
    constructor() {
        this.parsers = new Map();
    }
    addParser(lineType, parser) {
        const parsers = this.parsers.get(lineType) || [];
        parsers.push(parser);
        this.parsers.set(lineType, parsers);
    }
    getParsers(lineType) {
        return this.parsers.get(lineType) || [];
    }
}
class SdpGrammar extends Grammar {
    constructor() {
        super();
        this.addParser('v', VersionLine.fromSdpLine);
        this.addParser('o', OriginLine.fromSdpLine);
        this.addParser('c', ConnectionLine.fromSdpLine);
        this.addParser('i', SessionInformationLine.fromSdpLine);
        this.addParser('m', MediaLine.fromSdpLine);
        this.addParser('s', SessionNameLine.fromSdpLine);
        this.addParser('t', TimingLine.fromSdpLine);
        this.addParser('b', BandwidthLine.fromSdpLine);
        this.addParser('a', RtpMapLine.fromSdpLine);
        this.addParser('a', RtcpFbLine.fromSdpLine);
        this.addParser('a', FmtpLine.fromSdpLine);
        this.addParser('a', DirectionLine.fromSdpLine);
        this.addParser('a', ExtMapLine.fromSdpLine);
        this.addParser('a', MidLine.fromSdpLine);
        this.addParser('a', IceUfragLine.fromSdpLine);
        this.addParser('a', IcePwdLine.fromSdpLine);
        this.addParser('a', IceOptionsLine.fromSdpLine);
        this.addParser('a', FingerprintLine.fromSdpLine);
        this.addParser('a', SetupLine.fromSdpLine);
        this.addParser('a', SctpPortLine.fromSdpLine);
        this.addParser('a', MaxMessageSizeLine.fromSdpLine);
        this.addParser('a', RtcpMuxLine.fromSdpLine);
        this.addParser('a', BundleGroupLine.fromSdpLine);
        this.addParser('a', ContentLine.fromSdpLine);
        this.addParser('a', RidLine.fromSdpLine);
        this.addParser('a', CandidateLine.fromSdpLine);
        this.addParser('a', SimulcastLine.fromSdpLine);
        this.addParser('a', SsrcLine.fromSdpLine);
        this.addParser('a', SsrcGroupLine.fromSdpLine);
    }
}
const DefaultSdpGrammar = new SdpGrammar();
function isValidLine(line) {
    return line.length > 2;
}
function parseToModel(lines) {
    const sdp = new Sdp();
    let currBlock = sdp.session;
    lines.forEach((l) => {
        if (l instanceof MediaLine) {
            let mediaInfo;
            if (l.type === 'audio' || l.type === 'video') {
                mediaInfo = new AvMediaDescription(l);
            }
            else if (l.type === 'application') {
                mediaInfo = new ApplicationMediaDescription(l);
            }
            else {
                throw new Error(`Unhandled media type: ${l.type}`);
            }
            sdp.media.push(mediaInfo);
            currBlock = mediaInfo;
        }
        else {
            currBlock.addLine(l);
        }
    });
    return sdp;
}
function parseToLines(sdp, grammar) {
    const lines = [];
    sdp
        .split(/(\r\n|\r|\n)/)
        .filter(isValidLine)
        .forEach((l) => {
        const lineType = l[0];
        const lineValue = l.slice(2);
        const parsers = grammar.getParsers(lineType);
        for (const parser of parsers) {
            const result = parser(lineValue);
            if (result) {
                lines.push(result);
                return;
            }
        }
        const result = UnknownLine.fromSdpLine(l);
        lines.push(result);
    });
    return lines;
}
function parse(sdp, grammar = DefaultSdpGrammar) {
    const lines = parseToLines(sdp, grammar);
    const parsed = parseToModel(lines);
    return parsed;
}

function disableRtcpFbValue(sdp, rtcpFbValue) {
    sdp.avMedia.forEach((media) => {
        media.codecs.forEach((codec) => {
            codec.feedback = codec.feedback.filter((fb) => fb !== rtcpFbValue);
        });
    });
}
function disableRemb(sdp) {
    disableRtcpFbValue(sdp, 'goog-remb');
}
function removeCodec(sdp, codecName) {
    sdp.avMedia.forEach((media) => {
        const codecInfos = [...media.codecs.entries()].filter(([, ci]) => { var _a; return ((_a = ci.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === codecName.toLowerCase(); });
        codecInfos.forEach(([pt]) => media.removePt(pt));
    });
}

function hasCodec(codecName, mLine) {
    return [...mLine.codecs.values()].some((ci) => { var _a; return ((_a = ci.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === codecName.toLowerCase(); });
}

exports.ANY_NON_WS = ANY_NON_WS;
exports.ApplicationMediaDescription = ApplicationMediaDescription;
exports.AvMediaDescription = AvMediaDescription;
exports.BandwidthLine = BandwidthLine;
exports.BundleGroupLine = BundleGroupLine;
exports.CandidateLine = CandidateLine;
exports.CodecInfo = CodecInfo;
exports.ConnectionLine = ConnectionLine;
exports.ContentLine = ContentLine;
exports.DefaultSdpGrammar = DefaultSdpGrammar;
exports.DirectionLine = DirectionLine;
exports.ExtMapLine = ExtMapLine;
exports.FingerprintLine = FingerprintLine;
exports.FmtpLine = FmtpLine;
exports.Grammar = Grammar;
exports.IceInfo = IceInfo;
exports.IceOptionsLine = IceOptionsLine;
exports.IcePwdLine = IcePwdLine;
exports.IceUfragLine = IceUfragLine;
exports.Line = Line;
exports.MaxMessageSizeLine = MaxMessageSizeLine;
exports.MediaDescription = MediaDescription;
exports.MediaLine = MediaLine;
exports.MidLine = MidLine;
exports.NUM = NUM;
exports.OriginLine = OriginLine;
exports.REST = REST;
exports.RidLine = RidLine;
exports.RtcpFbLine = RtcpFbLine;
exports.RtcpMuxLine = RtcpMuxLine;
exports.RtpMapLine = RtpMapLine;
exports.SDP_TOKEN = SDP_TOKEN;
exports.SP = SP;
exports.SctpPortLine = SctpPortLine;
exports.Sdp = Sdp;
exports.SessionDescription = SessionDescription;
exports.SessionInformationLine = SessionInformationLine;
exports.SessionNameLine = SessionNameLine;
exports.SetupLine = SetupLine;
exports.SimulcastLayer = SimulcastLayer;
exports.SimulcastLayerList = SimulcastLayerList;
exports.SimulcastLine = SimulcastLine;
exports.SsrcGroupLine = SsrcGroupLine;
exports.SsrcLine = SsrcLine;
exports.TimingLine = TimingLine;
exports.VersionLine = VersionLine;
exports.WS = WS;
exports.disableRemb = disableRemb;
exports.disableRtcpFbValue = disableRtcpFbValue;
exports.hasCodec = hasCodec;
exports.parse = parse;
exports.parseFmtpParams = parseFmtpParams;
exports.parseToLines = parseToLines;
exports.parseToModel = parseToModel;
exports.removeCodec = removeCodec;
