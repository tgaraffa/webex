"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _webexCore = require("@webex/webex-core");

var _common = require("@webex/common");

var _config = require("./config");

var _batcher = _interopRequireDefault(require("./batcher"));

var _clientMetricsBatcher = _interopRequireDefault(require("./client-metrics-batcher"));

var _callDiagnosticEventsBatcher = _interopRequireDefault(require("./call-diagnostic-events-batcher"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }

var _BrowserDetection = (0, _common.BrowserDetection)(),
    getOSName = _BrowserDetection.getOSName,
    getOSVersion = _BrowserDetection.getOSVersion,
    getBrowserName = _BrowserDetection.getBrowserName,
    getBrowserVersion = _BrowserDetection.getBrowserVersion;

function getSparkUserAgent(webex) {
  var _webex$config;

  var _ref = (_webex$config = webex === null || webex === void 0 ? void 0 : webex.config) !== null && _webex$config !== void 0 ? _webex$config : {},
      appName = _ref.appName,
      appVersion = _ref.appVersion,
      appPlatform = _ref.appPlatform;

  var sparkUserAgent = _config.CLIENT_NAME;

  if (appName) {
    sparkUserAgent += " ".concat(appName, "/").concat(appVersion !== null && appVersion !== void 0 ? appVersion : '0.0');
  }

  if (appPlatform) {
    sparkUserAgent += " ".concat(appPlatform);
  }

  return sparkUserAgent;
}

var Metrics = _webexCore.WebexPlugin.extend({
  children: {
    batcher: _batcher.default,
    clientMetricsBatcher: _clientMetricsBatcher.default,
    callDiagnosticEventsBatcher: _callDiagnosticEventsBatcher.default
  },
  namespace: 'Metrics',
  submit: function submit(key, value) {
    return this.batcher.request((0, _assign.default)({
      key: key
    }, value));
  },

  /**
   * This corresponds to #sendSemiStructured() in the deprecated metrics handler
   * @param {string} eventName
   * @param {Object} props
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  submitClientMetrics: function submitClientMetrics(eventName) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var preLoginId = arguments.length > 2 ? arguments[2] : undefined;

    if (!eventName) {
      throw Error('Missing behavioral metric name. Please provide one');
    }

    var payload = {
      metricName: eventName
    };
    payload.tags = _objectSpread(_objectSpread({}, props.tags), {}, {
      browser: getBrowserName(),
      os: getOSName(),
      // Node does not like this so we need to check if it exists or not
      // eslint-disable-next-line no-undef
      domain: typeof window !== 'undefined' ? window.location.hostname || 'non-browser' : 'non-browser',
      // Check what else we could measure
      client_id: this.webex.credentials.config.client_id,
      user_id: this.webex.internal.device.userId
    });

    try {
      payload.tags.org_id = this.webex.credentials.getOrgId();
    } catch (_unused) {
      this.logger.info('metrics: unable to get orgId');
    }

    payload.fields = _objectSpread(_objectSpread({}, props.fields), {}, {
      browser_version: getBrowserVersion(),
      os_version: getOSVersion(),
      sdk_version: this.webex.version,
      platform: 'Web',
      spark_user_agent: getSparkUserAgent(this.webex)
    });
    payload.type = props.type || this.webex.config.metrics.type;
    payload.context = _objectSpread(_objectSpread({}, props.context), {}, {
      app: {
        version: this.webex.version
      },
      locale: 'en-US',
      os: {
        name: getOSName(),
        version: getOSVersion()
      }
    });

    if (props.eventPayload) {
      payload.eventPayload = props.eventPayload;
    } // Mocking the time in tests when running in node
    // is impossible so unable to use Date.now()


    payload.timestamp = new Date().valueOf();

    if (preLoginId) {
      var _payload = {
        metrics: [payload]
      }; // Do not batch these because pre-login events occur during onboarding, so we will be partially blind
      // to users' progress through the reg flow if we wait to persist pre-login metrics for people who drop off because
      // their metrics will not post from a queue flush in time

      return this.postPreLoginMetric(_payload, preLoginId);
    }

    return this.clientMetricsBatcher.request(payload);
  },

  /**
   * Issue request to alias a user's pre-login ID with their CI UUID
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  aliasUser: function aliasUser(preLoginId) {
    return this.request({
      method: 'POST',
      api: 'metrics',
      resource: 'clientmetrics',
      headers: {
        'x-prelogin-userid': preLoginId
      },
      body: {},
      qs: {
        alias: true
      }
    });
  },
  postPreLoginMetric: function postPreLoginMetric(payload, preLoginId) {
    var _this = this;

    return this.webex.credentials.getClientToken().then(function (token) {
      return _this.request({
        method: 'POST',
        api: 'metrics',
        resource: 'clientmetrics-prelogin',
        headers: {
          authorization: token.toString(),
          'x-prelogin-userid': preLoginId
        },
        body: payload
      });
    });
  },
  submitCallDiagnosticEvents: function submitCallDiagnosticEvents(payload) {
    var event = {
      type: 'diagnostic-event',
      eventPayload: payload
    };
    return this.callDiagnosticEventsBatcher.request(event);
  },
  version: "2.29.3"
});

var _default = Metrics;
exports.default = _default;
//# sourceMappingURL=metrics.js.map
