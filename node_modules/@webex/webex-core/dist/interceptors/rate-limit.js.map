{"version":3,"names":["rateLimitExpiryTime","idBrokerRegex","RateLimitInterceptor","args","set","options","isRateLimited","uri","reject","Error","resolve","reason","statusCode","includes","setRateLimitExpiry","extractRetryAfterTime","milliMultiplier","retryAfter","headers","apiName","getApiName","currTimeMilli","Date","getTime","expiry","dict","get","expiryTime","undefined","results","match","getRateLimitStatus","webex","Interceptor"],"sources":["rate-limit.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n// contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\nconst rateLimitExpiryTime = new WeakMap();\n\n// extracts the common identity API being called\nconst idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n\n/**\n * @class\n */\nexport default class RateLimitInterceptor extends Interceptor {\n  /**\n   * @returns {RateLimitInterceptor}\n   */\n  static create() {\n    return new RateLimitInterceptor({webex: this});\n  }\n\n  /**\n  * constructor\n  * @param {mixed} args\n  * @returns {Exception}\n  */\n  constructor(...args) {\n    super(...args);\n    rateLimitExpiryTime.set(this, new Map());\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    if (this.isRateLimited(options.uri)) {\n      return Promise.reject(new Error(`API rate limited ${options.uri}`));\n    }\n\n    return Promise.resolve(options);\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n      // set the retry after in the map, setting to milliseconds\n      this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n    }\n\n    return Promise.reject(reason);\n  }\n\n  /**\n   * @param {object} options associated with the request\n   * @returns {number} retry after time in milliseconds\n   */\n  extractRetryAfterTime(options) {\n    // 1S * 1K === 1MS\n    const milliMultiplier = 1000;\n    const retryAfter = options.headers['retry-after'] || null;\n\n    // set 60 retry if no usable time defined\n    if (retryAfter === null || retryAfter <= 0) {\n      return 60 * milliMultiplier;\n    }\n    // set max to 3600 S (1 hour) if greater than 1 hour\n    if (retryAfter > 3600) {\n      return 3600 * milliMultiplier;\n    }\n\n    return retryAfter * milliMultiplier;\n  }\n\n  /**\n   * Set the system time at which the rate limiting\n   * will expire in the rateLimitExpiryTime map.\n   * Assumes retryAfter is in milliseconds\n   * @param {string} uri API issuing the rate limiting\n   * @param {number} retryAfter milliseconds until rate limiting expires\n   * @returns {bool} true is value was successfully set\n   */\n  setRateLimitExpiry(uri, retryAfter) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const expiry = currTimeMilli + retryAfter;\n    const dict = rateLimitExpiryTime.get(this);\n\n    return dict.set(apiName, expiry);\n  }\n\n  /**\n   * returns true if the API is currently rate limited\n   * @param {string} uri\n   * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n   */\n  getRateLimitStatus(uri) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const dict = rateLimitExpiryTime.get(this);\n    const expiryTime = dict.get(apiName);\n\n    // if no rate limit expiry has been registered in the map, return false.\n    if (expiryTime === undefined) {\n      return false;\n    }\n\n    // return true, indicating rate limiting, if the system time is less than the expiry time\n    return currTimeMilli < dict.get(apiName);\n  }\n\n  /**\n   * split the URI and returns the API name of idBroker\n   * @param {string} uri\n   * @returns {string}\n   */\n  getApiName(uri) {\n    if (!uri) {\n      return null;\n    }\n\n    const results = uri.match(idBrokerRegex);\n\n    if (!results) {\n      return null;\n    }\n\n    // group 0 = full match of URL, group 1 = identity or idbroker base\n    // group 2 = api name\n    return results[2];\n  }\n\n  /**\n   * check URI against list of currently rate limited\n   * URIs, and determines if retry-after\n   * @param {String} uri pattern to check\n   * @returns {bool}\n   */\n  isRateLimited(uri) {\n    // determine if the URI is associated with a common identity API\n    if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n      return this.getRateLimitStatus(uri);\n    }\n\n    return false;\n  }\n}\n"],"mappings":"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"}