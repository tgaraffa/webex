{"version":3,"names":["trailingSlashes","Services","WebexPlugin","extend","namespace","registries","states","props","validateDomains","_catalogs","_serviceUrls","getRegistry","get","webex","getState","_getCatalog","name","priorityHost","serviceGroup","catalog","hasService","serviceName","hasAllowedDomains","getAllowedDomains","length","list","markFailedUrl","url","noPriorityHosts","_updateServiceUrls","serviceUrls","updateServices","from","query","token","forceRefresh","formattedQuery","status","collecting","waitForCatalog","queryKey","includes","reject","Error","email","emailhash","sha256","toLowerCase","toString","_fetchNewServiceHostmap","then","serviceHostMap","updateServiceUrls","updateCredentialsConfig","catch","error","validateUser","reqId","activationOptions","preloginUserId","logger","info","canAuthorize","credentials","getUserToken","sendUserActivation","userObj","activated","exists","details","user","config","client_id","client_secret","collectPreauthCatalog","idbrokerService","getClientToken","uri","scope","tokenObj","collectSigninCatalog","rto","all","response","statusCode","responseText","body","message","getMeetingPreferences","request","method","WEBEXAPI","res","err","fetchClientRegionInfo","addAuthHeader","headers","countryCode","timezone","clientRegionInfo","service","resource","accept","authorization","timeZone","shouldRefreshAccessToken","mode","idbroker","identity","authorizationString","authorizeUrl","replace","setConfig","timeout","supertoken","access_token","postauth","ready","preauth","initServiceCatalogs","waitForService","services","fetchFromServiceUrl","servicesNotNeedValidation","find","resolve","priorityUrl","priorityUrlObj","getServiceFromUrl","isReady","internal","metrics","submitClientMetrics","METRICS","JS_SDK_SERVICE_NOT_FOUND","fields","service_name","groupsToCheck","checkCatalog","catalogGroup","scopedPriorityUrl","scopedPrioriryUrlObj","undefined","map","group","_formatReceivedHostmap","serviceHostmap","formattedHostmap","hostCatalog","reduce","accumulator","key","id","split","defaultUrl","serviceLinks","serviceItem","item","defaultHost","Url","parse","hostname","hosts","push","host","ttl","priority","homeCluster","forEach","getClusterId","findClusterId","getServiceFromClusterId","params","findServiceFromClusterId","findServiceUrlFromUrl","isServiceUrl","isAllowedDomainUrl","findAllowedDomain","convertUrlToPriorityHostUrl","data","qs","format","timestamp","Date","getTime","requestObject","initConfig","fedramp","discovery","fedRampServices","formattedDiscoveryServices","override","formattedOverrideServices","allowedDomains","setAllowedDomains","getOrgId","orgId","warn","initialize","ServiceCatalog","registry","ServiceRegistry","state","ServiceState","set","listenToOnce"],"sources":["services.js"],"sourcesContent":["import Url from 'url';\n\nimport sha256 from 'crypto-js/sha256';\n\nimport WebexPlugin from '../webex-plugin';\n\nimport METRICS from './metrics';\nimport ServiceCatalog from './service-catalog';\nimport ServiceRegistry from './service-registry';\nimport ServiceState from './service-state';\nimport fedRampServices from './service-fed-ramp';\nimport {WEBEXAPI} from './constants';\n\nconst trailingSlashes = /(?:^\\/)|(?:\\/$)/;\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  /**\n   * The {@link WeakMap} of {@link ServiceRegistry} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceRegistry>}\n   * @private\n   * @memberof Services\n   */\n  registries: new WeakMap(),\n\n  /**\n   * The {@link WeakMap} of {@link ServiceState} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceState>}\n   * @private\n   * @memberof Services\n   */\n  states: new WeakMap(),\n\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n\n  _catalogs: new WeakMap(),\n\n  _serviceUrls: null,\n\n  /**\n   * Get the registry associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceRegistry} - The associated {@link ServiceRegistry}.\n   */\n  getRegistry() {\n    return this.registries.get(this.webex);\n  },\n\n  /**\n   * Get the state associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceState} - The associated {@link ServiceState}.\n   */\n  getState() {\n    return this.states.get(this.webex);\n  },\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService(serviceName) {\n    return !!(this.get(serviceName));\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains() {\n    const catalog = this._getCatalog();\n\n    return (catalog.getAllowedDomains().length > 0);\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n * saves all the services from the pre and post catalog service\n * @param {Object} serviceUrls\n * @returns {void}\n */\n  _updateServiceUrls(serviceUrls) {\n    this._serviceUrls = {...this._serviceUrls, ...serviceUrls};\n  },\n\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({\n    from, query, token, forceRefresh\n  } = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery, serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited': serviceGroup = 'preauth'; break;\n      case 'signin': serviceGroup = 'signin'; break;\n      default: serviceGroup = 'postauth'; break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      const queryKey = query && Object.keys(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return Promise.reject(new Error('a query param of email, emailhash, userId, orgId, or mode is required'));\n      }\n    }\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n\n      if (queryKey === 'email' && query.email) {\n        formattedQuery.emailhash = sha256(query.email.toLowerCase()).toString();\n      }\n      else {\n        formattedQuery[queryKey] = query[queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery,\n      forceRefresh\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   * @property {object} [ValidateUserPTO.activationOptions] - Extra options to pass when sending the activation\n   * @property {object} [ValidateUserPTO.preloginUserId] - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **License** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser({\n    email,\n    reqId = 'WEBCLIENT',\n    forceRefresh = false,\n    activationOptions = {},\n    preloginUserId\n  }) {\n    this.logger.info('services: validating a user');\n\n    // Validate that an email parameter key was provided.\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    // Destructure the credentials object.\n    const {canAuthorize} = this.webex.credentials;\n\n    // Validate that the user is already authorized.\n    if (canAuthorize) {\n      return this.updateServices({forceRefresh})\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) => this.sendUserActivation({\n          email,\n          reqId,\n          token: token.toString(),\n          activationOptions,\n          preloginUserId\n        }))\n        .then((userObj) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        }));\n    }\n\n    // Destructure the client authorization details.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    // Validate that client authentication details exist.\n    if (!client_id || !client_secret) {\n      return Promise.reject(new Error(\n        'client authentication details are not available'\n      ));\n    }\n    /* eslint-enable camelcase */\n\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n    let token;\n\n    // Begin client authentication user validation.\n    return this.collectPreauthCatalog({email})\n      .then(() => {\n        // Retrieve the service url from the updated catalog. This is required\n        // since `WebexCore` is usually not fully initialized at the time this\n        // request completes.\n        const idbrokerService = this.get('idbroker', true);\n\n        // Collect the client auth token.\n        return this.webex.credentials.getClientToken({\n          uri: `${idbrokerService}idb/oauth2/v1/access_token`,\n          scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n        });\n      })\n      .then((tokenObj) => {\n        // Generate the token string.\n        token = tokenObj.toString();\n\n        // Collect the signin catalog using the client auth information.\n        return this.collectSigninCatalog({email, token, forceRefresh});\n      })\n      // Validate if collecting the signin catalog failed and populate the RTO\n      // with the appropriate content.\n      .catch((error) => ({\n        exists: (error.name !== 'NotFound'),\n        activated: false,\n        details: (error.name !== 'NotFound') ?\n          'user exists but is not activated' :\n          'user does not exist and is not activated'\n      }))\n      // Validate if the previous promise resolved with an RTO and populate the\n      // new RTO accordingly.\n      .then((rto) => Promise.all([\n        rto || {\n          activated: true,\n          exists: true,\n          details: 'user exists and is activated'\n        },\n        this.sendUserActivation({\n          email,\n          reqId,\n          token,\n          activationOptions,\n          preloginUserId\n        })\n      ]))\n      .then(([rto, user]) => ({...rto, user}))\n      .catch((error) => {\n        const response = {\n          statusCode: error.statusCode,\n          responseText: error.body && error.body.message,\n          body: error.body\n        };\n\n        return Promise.reject(response);\n      });\n  },\n\n  /**\n   * Get user meeting preferences (preferred webex site).\n   *\n   * @returns {object} - User Information including user preferrences .\n   */\n  getMeetingPreferences() {\n    return this.request({\n      method: 'GET',\n      url: `${WEBEXAPI}v1/meetingPreferences`\n    }).then((res) => {\n      this.logger.info('services: received user region info');\n\n      return res.body;\n    }).catch((err) => {\n      this.logger.info('services: was not able to fetch user login information', err);\n      // resolve successfully even if request failed\n    });\n  },\n\n\n  /**\n   * Fetches client region info such as countryCode and timezone.\n   *\n   * @returns {object} - The region info object.\n   */\n  fetchClientRegionInfo() {\n    return this.request({\n      uri: 'https://ds.ciscospark.com/v1/region',\n      addAuthHeader: false,\n      headers: {\n        'spark-user-agent': null\n      }\n    }).then((res) => {\n      this.logger.info('services: received user region info');\n\n      return res.body;\n    }).catch((err) => {\n      this.logger.info('services: was not able to get user region info', err);\n      // resolve successfully even if request failed\n    });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   * @property {object} SendUserActivationPTO.activationOptions - Extra options to pass when sending the activation.\n   * @property {object} SendUserActivationPTO.preloginUserId - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {LicenseDTO} - The DTO returned from the **License** service.\n   */\n  sendUserActivation({\n    email,\n    reqId,\n    token,\n    activationOptions,\n    preloginUserId\n  }) {\n    this.logger.info('services: sending user activation request');\n    let countryCode, timezone;\n\n\n    // try to fetch client region info first\n    return this.fetchClientRegionInfo()\n      .then((clientRegionInfo) => {\n        if (clientRegionInfo) {\n          ({countryCode, timezone} = clientRegionInfo);\n        }\n\n        // Send the user activation request to the **License** service.\n        return this.request({\n          service: 'license',\n          resource: 'users/activations',\n          method: 'POST',\n          headers: {\n            accept: 'application/json',\n            authorization: token,\n            'x-prelogin-userid': preloginUserId\n          },\n          body: {\n            email,\n            reqId,\n            countryCode,\n            timeZone: timezone,\n            ...activationOptions\n          },\n          shouldRefreshAccessToken: false\n        });\n      })\n      // On success, return the **License** user object.\n      .then(({body}) => body)\n      // On failure, reject with error from **License**.\n      .catch((error) => Promise.reject(error));\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @param {boolean} forceRefresh - Boolean to bypass u2c cache control header\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog(query, forceRefresh = false) {\n    if (!query) {\n      return this.updateServices({from: 'limited', query: {mode: 'DEFAULT_BY_PROXIMITY'}, forceRefresh});\n    }\n\n    return this.updateServices({from: 'limited', query, forceRefresh});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token, forceRefresh} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({\n      from: 'signin', query: {email}, token, forceRefresh\n    });\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      const {authorizationString, authorizeUrl} = this.webex.config.credentials;\n\n      // This must be set outside of the setConfig method used to assign the\n      // idbroker and identity url values.\n      this.webex.config.credentials.authorizeUrl = authorizationString ?\n        authorizeUrl :\n        `${idbroker.replace(trailingSlashes, '')}/idb/oauth2/v1/authorize`;\n\n\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.replace(trailingSlashes, '') // remove trailing slash\n          },\n          identity: {\n            url: identity.replace(trailingSlashes, '') // remove trailing slash\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n    const {supertoken} = this.webex.credentials;\n\n    if (\n      serviceGroup === 'postauth' &&\n      supertoken &&\n      supertoken.access_token &&\n      !catalog.status.postauth.collecting &&\n      !catalog.status.postauth.ready\n    ) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService({name, timeout = 5, url}) {\n    const {services} = this.webex.config;\n\n    // Save memory by grabbing the catalog after there isn't a priortyURL\n    const catalog = this._getCatalog();\n\n    const fetchFromServiceUrl = services.servicesNotNeedValidation.find((service) => service === name);\n\n    if (fetchFromServiceUrl) {\n      return Promise.resolve(this._serviceUrls[name]);\n    }\n\n    const priorityUrl = this.get(name, true);\n    const priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return Promise.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    if (catalog.isReady) {\n      if (url) { return Promise.resolve(url); }\n\n      this.webex.internal.metrics.submitClientMetrics(METRICS.JS_SDK_SERVICE_NOT_FOUND, {\n        fields: {service_name: name}\n      });\n\n      return Promise.reject(new Error(\n        `services: service '${name}' was not found in any of the catalogs`\n      ));\n    }\n\n    return new Promise((resolve, reject) => {\n      const groupsToCheck = ['preauth', 'signin', 'postauth'];\n      const checkCatalog = (catalogGroup) =>\n        catalog.waitForCatalog(catalogGroup, timeout)\n          .then(() => {\n            const scopedPriorityUrl = this.get(name, true);\n            const scopedPrioriryUrlObj = this.getServiceFromUrl(url);\n\n            if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n              resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n            }\n          })\n          .catch(() => undefined);\n\n      Promise.all(groupsToCheck.map((group) => checkCatalog(group)))\n        .then(() => {\n          this.webex.internal.metrics.submitClientMetrics(METRICS.JS_SDK_SERVICE_NOT_FOUND, {\n            fields: {service_name: name}\n          });\n          reject(new Error(\n            `services: service '${name}' was not found after waiting`\n          ));\n        });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    const formattedHostmap = Object.keys(serviceHostmap.hostCatalog).reduce(\n      (accumulator, key) => {\n        if (serviceHostmap.hostCatalog[key].length === 0) {\n          return accumulator;\n        }\n\n        const serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n        const defaultUrl = serviceHostmap.serviceLinks[serviceName];\n\n        let serviceItem = accumulator.find(\n          (item) => item.name === serviceName\n        );\n\n        if (!serviceItem) {\n          serviceItem = {\n            name: serviceName,\n            defaultUrl,\n            defaultHost: Url.parse(defaultUrl).hostname,\n            hosts: []\n          };\n\n          accumulator.push(serviceItem);\n        }\n\n        serviceItem.hosts.push(\n          // map the default key as a low priority default for cluster matching\n          {\n            host: key,\n            ttl: -1,\n            priority: 10,\n            id: serviceHostmap.hostCatalog[key][0].id,\n            homeCluster: serviceItem.defaultHost === key\n          },\n          // map the rest of the hosts in their proper locations\n          ...serviceHostmap.hostCatalog[key].map(\n            (host) => ({\n              ...host,\n              homeCluster: serviceItem.defaultHost === key\n            })\n          )\n        );\n\n        return accumulator;\n      }, []\n    );\n\n    // append service links that do not exist in the host catalog\n    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {\n      const service = formattedHostmap.find((item) => item.name === key);\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: Url.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n\n    // update all the service urls in the host catalog\n\n    this._updateServiceUrls(serviceHostmap.serviceLinks);\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl(url = '') {\n    const service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findServiceUrlFromUrl(url));\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findAllowedDomain(url));\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl(url = '') {\n    const data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(`No service associated with url: [${url}]`);\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({\n    from, query, token, forceRefresh\n  } = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...query, format: 'hostmap'};\n\n    if (forceRefresh) {\n      qs.timestamp = new Date().getTime();\n    }\n\n    const requestObject = {\n      method: 'GET', service, resource, qs\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.request(requestObject)\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig() {\n    // Get the catalog and destructure the services config.\n    const catalog = this._getCatalog();\n    const {services, fedramp} = this.webex.config;\n\n    // Validate that the services configuration exists.\n    if (services) {\n      if (fedramp) {\n        services.discovery = fedRampServices;\n      }\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        const formattedDiscoveryServices = Object.keys(services.discovery)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.discovery[key]\n          }));\n\n        // Inject formatted discovery services into services catalog.\n        catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n      }\n\n      if (services.override) {\n        // Format the override configuration into an injectable array.\n        const formattedOverrideServices = Object.keys(services.override)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.override[key]\n          }));\n\n        // Inject formatted override services into services catalog.\n        catalog.updateServiceUrls('override', formattedOverrideServices);\n      }\n\n      // Check for allowed host domains.\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      }\n\n      // Set `validateDomains` property to match configuration\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs() {\n    this.logger.info('services: initializing initial service catalogs');\n\n    // Destructure the credentials plugin.\n    const {credentials} = this.webex;\n\n    // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n    return Promise.resolve()\n      // Get the user's OrgId.\n      .then(() => credentials.getOrgId())\n      // Begin collecting the preauth/limited catalog.\n      .then((orgId) => this.collectPreauthCatalog({orgId}))\n      .then(() => {\n        // Validate if the token is authorized.\n        if (credentials.canAuthorize) {\n          // Attempt to collect the postauth catalog.\n          return this.updateServices()\n            .catch(() => this.logger.warn(\n              'services: cannot retrieve postauth catalog'\n            ));\n        }\n\n        // Return a resolved promise for consistent return value.\n        return Promise.resolve();\n      });\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n    const registry = new ServiceRegistry();\n    const state = new ServiceState();\n\n    this._catalogs.set(this.webex, catalog);\n    this.registries.set(this.webex, registry);\n    this.states.set(this.webex, state);\n\n    // Listen for configuration changes once.\n    this.listenToOnce(this.webex, 'change:config', () => {\n      this.initConfig();\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      const {supertoken} = this.webex.credentials;\n\n      // Validate if the supertoken exists.\n      if (supertoken && supertoken.access_token) {\n        this.initServiceCatalogs()\n          .then(() => {\n            catalog.isReady = true;\n          })\n          .catch((error) => this.logger.error(\n            `services: failed to init initial services, ${error.message}`\n          ));\n      }\n      else {\n        const {email} = this.webex.config;\n\n        this.collectPreauthCatalog(email ? {email} : undefined);\n      }\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"],"mappings":"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"}