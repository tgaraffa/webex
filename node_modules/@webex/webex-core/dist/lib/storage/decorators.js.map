{"version":3,"names":["persist","args","length","key","decider","persistDecorator","target","prop","descriptor","TypeError","value","persistExecutor","fn","initializeArgs","ret","changeEvent","on","shouldPersist","Reflect","resolve","boundedStorage","put","prepareInitialize","M","S","BlockingKeyMap","make","blockingKeys","waitForValue","Error","waitForValueDecorator","add","waitForValueExecutor","keys","get","all","map","k","waitFor","then","prototype","inited","identifyTarget","namespace","stack","id","has","initialize","applyInit","init","self","getNamespace","webex","set","logger","debug","parent","toLowerCase","handle","reason","NotFoundError","process","env","NODE_ENV","toString","includes","error","reject","promises","forEach","push","catch","delete","size","loaded"],"sources":["decorators.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\nimport {\n  curry,\n  debounce,\n  identity,\n  result,\n  wrap\n} from 'lodash';\nimport {make} from '@webex/common';\n\nimport {NotFoundError} from './errors';\n\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\nexport function persist(...args) {\n  if (args.length === 3) {\n    return persist('@')(...args);\n  }\n\n  const [key, decider] = args;\n\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = wrap(descriptor.value, function persistExecutor(fn, ...initializeArgs) {\n      const ret = Reflect.apply(fn, this, initializeArgs);\n      const changeEvent = key === '@' ? 'change' : `change:${key}`;\n\n      // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n      this.on(changeEvent, debounce(() => {\n        const shouldPersist = !decider || Reflect.apply(decider, this, ...initializeArgs);\n\n        if (!shouldPersist) {\n          return Promise.resolve();\n        }\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return this.boundedStorage.put(key, this);\n        }\n\n        // eslint-disable-next-line no-invalid-this\n        return this.boundedStorage.put(key, this[key]);\n      }, 0));\n\n      return ret;\n    });\n\n    prepareInitialize(target, prop);\n  };\n}\n\nconst M = Map;\nconst S = Set;\nconst BlockingKeyMap = make(M, M, S);\nconst blockingKeys = new BlockingKeyMap();\n\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\nexport function waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = wrap(descriptor.value, function waitForValueExecutor(fn, ...args) {\n      const keys = blockingKeys.get(target, prop);\n\n      return Promise.all([...keys].map((k) => this.boundedStorage.waitFor(k)))\n        .then(() => Reflect.apply(fn, this, args));\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n\n    return descriptor;\n  };\n}\n\nconst inited = new Set();\n\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nconst stack = new Set();\n\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\nfunction prepareInitialize(target, prop) {\n  const id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n    if (target.initialize) {\n      target.initialize = wrap(target.initialize, function applyInit(fn, ...args) {\n        const ret = Reflect.apply(fn, this, args);\n\n        Reflect.apply(init, this, args);\n\n        return ret;\n      });\n\n      return;\n    }\n\n    target.initialize = init;\n  }\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function init() {\n    const self = this;\n    const namespace = this.getNamespace();\n\n    this.webex.initialize = wrap(this.webex.initialize || identity, function applyInit(fn, ...args) {\n      // Call webex's initalize method first\n      // Reminder: in order for MockWebex to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `webex`, not `self`.\n      stack.add(namespace);\n      Reflect.apply(fn, this, args);\n\n      // Then prepare a function for setting values retrieved from storage\n      const set = curry((key, value) => {\n        this.logger.debug(`storage:(${namespace}): got \\`${key}\\` for first time`);\n        if (key === '@') {\n          self.parent.set({\n            [namespace.toLowerCase()]: value\n          });\n        }\n        else if (result(self[key], 'isState')) {\n          self[key].set(value);\n        }\n        else {\n          self.set(key, value);\n        }\n        this.logger.debug(`storage:(${namespace}): set \\`${key}\\` for first time`);\n      });\n\n      // And prepare an error handler for when those keys can't be found\n      const handle = curry((key, reason) => {\n        if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          this.logger.debug(`storage(${namespace}): no data for \\`${key}\\`, continuing`);\n\n          return Promise.resolve();\n        }\n        this.logger.error(`storage(${namespace}): failed to init \\`${key}\\``, reason);\n\n        return Promise.reject(reason);\n      });\n\n      // Iterate over the list of keys marked as blocking via `@waitForValue`\n      const keys = blockingKeys.get(target, prop);\n      const promises = [];\n\n      keys.forEach((key) => {\n        promises.push(this.boundedStorage.get(namespace, key)\n          .then(set(key))\n          .catch(handle(key)));\n      });\n\n      Promise.all(promises)\n        .then(() => {\n          stack.delete(namespace);\n          if (stack.size === 0) {\n            this.loaded = true;\n          }\n        });\n    });\n  }\n}\n"],"mappings":"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"}