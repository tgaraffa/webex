{"version":3,"names":["processGrantError","res","statusCode","reject","ErrorConstructor","grantErrors","select","body","error","OAuthError","WebexHttpError","_res","Token","WebexPlugin","extend","oneFlight","keyFactory","scope","derived","canAuthorize","deps","fn","access_token","isExpired","canDownscope","config","client_id","canRefresh","inBrowser","refresh_token","refreshCallback","client_secret","expires","_isExpired","_string","token_type","namespace","props","expires_in","refresh_token_expires","refresh_token_expires_in","default","type","session","previousToken","downscope","logger","info","Error","trace","sortScope","webex","request","method","uri","tokenUrl","addAuthHeader","form","grant_type","token","self_contained_token","then","parent","initialize","attrs","options","prototype","safeSetTimeout","refresh","promise","resolve","redirect_uri","auth","user","pass","sendImmediately","shouldRefreshAccessToken","obj","process","env","NODE_ENV","revoke","unset","catch","revokeUrl","token_type_hint","set","_filterSetParameters","includes","split","now","toString","validate","service","resource","reason","convApi","CONVERSATION_SERVICE","CONVERSATION_SERVICE_URL","headers","authorization"],"sources":["token.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {pick} from 'lodash';\nimport {inBrowser, oneFlight} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\n\nimport WebexHttpError from '../webex-http-error';\nimport WebexPlugin from '../webex-plugin';\n\nimport {sortScope} from './scope';\nimport grantErrors, {OAuthError} from './grant-errors';\n\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {WebexHttpError} res\n * @private\n * @returns {GrantError}\n */\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return Promise.reject(res);\n  }\n\n  const ErrorConstructor = grantErrors.select(res.body.error);\n\n  if (ErrorConstructor === OAuthError && res instanceof WebexHttpError) {\n    return Promise.reject(res);\n  }\n  if (!ErrorConstructor) {\n    return Promise.reject(res);\n  }\n\n  return Promise.reject(new ErrorConstructor(res._res || res));\n}\n\n/**\n * @class\n */\nconst Token = WebexPlugin.extend({\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn() {\n        if (inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n\n        return `${this.token_type} ${this.access_token}`;\n      }\n    }\n  },\n\n  namespace: 'Credentials',\n\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  @oneFlight({\n    keyFactory(scope) {\n      return scope;\n    }\n  })\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    this.logger.info(`token: downscoping token to ${scope}`);\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n\n      return Promise.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      }\n      else {\n        this.logger.trace('token: cannot downscope without client_id');\n      }\n\n      return Promise.reject(new Error('cannot downscope access token'));\n    }\n\n    // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n    if (scope) {\n      scope = sortScope(scope);\n    }\n\n    // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n    if (scope === sortScope(this.config.scope)) {\n      return Promise.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      addAuthHeader: false,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope,\n        client_id: this.config.client_id,\n        self_contained_token: true\n      }\n    })\n      .then((res) => {\n        this.logger.info(`token: downscoped token to ${scope}`);\n\n        return new Token(Object.assign(res.body, {scope}), {parent: this.parent});\n      });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link WebexPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize(attrs = {}, options = {}) {\n    Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    }\n\n    // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n    if (this.expires) {\n      if (this.expires < Date.now()) {\n        this._isExpired = true;\n      }\n      else {\n        safeSetTimeout(() => {\n          this._isExpired = true;\n        }, this.expires - Date.now());\n      }\n    }\n  },\n\n  @oneFlight\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh() {\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    let promise;\n\n    if (inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = Promise.resolve(this.config.refreshCallback(this.webex, this));\n    }\n\n    return (promise || this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then((res) => res.body))\n      .then((obj) => {\n        if (!obj) {\n          throw new Error('token: refreshCallback() did not produce an object');\n        }\n        // If the authentication server did not send back a refresh token, copy\n        // the current refresh token and related values to the response (note:\n        // at time of implementation, CI never sends a new refresh token)\n        if (!obj.refresh_token) {\n          Object.assign(obj, pick(this, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n        }\n\n        // If the new token is the same as the previous token, then we may have\n        // found a bug in CI; log the details and reject the Promise\n        if (this.access_token === obj.access_token) {\n          this.logger.error('token: new token matches current token');\n          // log the tokens if it is not production\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error('token: current token:', this.access_token);\n            this.logger.error('token: new token:', obj.access_token);\n          }\n\n          return Promise.reject(new Error('new token matches current token'));\n        }\n\n        if (this.previousToken) {\n          this.previousToken.revoke();\n          this.unset('previousToken');\n        }\n\n        obj.previousToken = this;\n        obj.scope = this.scope;\n\n        return new Token(obj, {parent: this.parent});\n      })\n      .catch(processGrantError);\n  },\n\n  @oneFlight\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke() {\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n\n      return Promise.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n\n      return Promise.resolve();\n    }\n\n    // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n\n      return Promise.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then(() => {\n        this.unset([\n          'access_token',\n          'expires',\n          'expires_in',\n          'token_type'\n        ]);\n        this.logger.info('token: access token revoked');\n      })\n      .catch(processGrantError);\n  },\n\n  set(...args) {\n    // eslint-disable-next-line prefer-const\n    let [attrs, options] = this._filterSetParameters(...args);\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      const [token_type, access_token] = attrs.access_token.split(' ');\n\n      attrs = Object.assign({}, attrs, {access_token, token_type});\n    }\n    const now = Date.now();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = sortScope(attrs.scope);\n    }\n\n    return Reflect.apply(WebexPlugin.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate() {\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    })\n      .catch((reason) => {\n        if ('statusCode' in reason) {\n          return Promise.reject(reason);\n        }\n        this.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal');\n\n        // If we got an error that isn't a WebexHttpError, assume the problem is\n        // that we don't have the wdm plugin loaded and service/resource isn't\n        // a valid means of identifying a request.\n        const convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n\n        return this.webex.request({\n          method: 'POST',\n          uri: `${convApi}/users/validateAuthToken`,\n          body: {\n            token: this.access_token\n          },\n          headers: {\n            authorization: `Bearer ${this.access_token}`\n          }\n        });\n      })\n      .then((res) => res.body);\n  }\n});\n\nexport default Token;\n"],"mappings":"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"}