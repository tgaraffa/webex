"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _common = require("@webex/common");

var _metrics = _interopRequireDefault(require("../metrics"));

var _constants = _interopRequireDefault(require("../metrics/constants"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants2 = require("../constants");

var TURN_DISCOVERY_TIMEOUT = 10; // in seconds

/**
 * Handles the process of finding out TURN server information from Linus.
 * This is achieved by sending a TURN_DISCOVERY_REQUEST.
 */

var TurnDiscovery = /*#__PURE__*/function () {
  // used for waiting for the response

  /**
   * Constructor
   *
   * @param {RoapRequest} roapRequest
   */
  function TurnDiscovery(roapRequest) {
    (0, _classCallCheck2.default)(this, TurnDiscovery);
    (0, _defineProperty2.default)(this, "roapRequest", void 0);
    (0, _defineProperty2.default)(this, "defer", void 0);
    (0, _defineProperty2.default)(this, "turnInfo", void 0);
    (0, _defineProperty2.default)(this, "responseTimer", void 0);
    this.roapRequest = roapRequest;
    this.turnInfo = {
      url: '',
      username: '',
      password: ''
    };
  }
  /**
   * waits for TURN_DISCOVERY_RESPONSE message to arrive
   *
   * @returns {Promise}
   * @private
   * @memberof Roap
   */


  (0, _createClass2.default)(TurnDiscovery, [{
    key: "waitForTurnDiscoveryResponse",
    value: function waitForTurnDiscoveryResponse() {
      if (!this.defer) {
        _loggerProxy.default.logger.warn('Roap:turnDiscovery#waitForTurnDiscoveryResponse --> TURN discovery is not in progress');

        return _promise.default.reject(new Error('waitForTurnDiscoveryResponse() called before sendRoapTurnDiscoveryRequest()'));
      }

      var defer = this.defer;
      this.responseTimer = setTimeout(function () {
        _loggerProxy.default.logger.warn("Roap:turnDiscovery#waitForTurnDiscoveryResponse --> timeout! no response arrived within ".concat(TURN_DISCOVERY_TIMEOUT, " seconds"));

        defer.reject(new Error('Timed out waiting for TURN_DISCOVERY_RESPONSE'));
      }, TURN_DISCOVERY_TIMEOUT * 1000);

      _loggerProxy.default.logger.info('Roap:turnDiscovery#waitForTurnDiscoveryResponse --> waiting for TURN_DISCOVERY_RESPONSE...');

      return defer.promise;
    }
    /**
     * handles TURN_DISCOVERY_RESPONSE roap message
     *
     * @param {Object} roapMessage
     * @returns {void}
     * @public
     * @memberof Roap
     */

  }, {
    key: "handleTurnDiscoveryResponse",
    value: function handleTurnDiscoveryResponse(roapMessage) {
      var _this = this;

      var headers = roapMessage.headers;

      if (!this.defer) {
        _loggerProxy.default.logger.warn('Roap:turnDiscovery#handleTurnDiscoveryResponse --> unexpected TURN discovery response');

        return;
      }

      var expectedHeaders = [{
        headerName: 'x-cisco-turn-url',
        field: 'url'
      }, {
        headerName: 'x-cisco-turn-username',
        field: 'username'
      }, {
        headerName: 'x-cisco-turn-password',
        field: 'password'
      }];
      var foundHeaders = 0;
      headers === null || headers === void 0 ? void 0 : headers.forEach(function (receivedHeader) {
        // check if it matches any of our expected headers
        expectedHeaders.forEach(function (expectedHeader) {
          if (receivedHeader.startsWith("".concat(expectedHeader.headerName, "="))) {
            _this.turnInfo[expectedHeader.field] = receivedHeader.substring(expectedHeader.headerName.length + 1);
            foundHeaders += 1;
          }
        });
      });
      clearTimeout(this.responseTimer);
      this.responseTimer = undefined;

      if (foundHeaders !== expectedHeaders.length) {
        _loggerProxy.default.logger.warn("Roap:turnDiscovery#handleTurnDiscoveryResponse --> missing some headers, received: ".concat((0, _stringify.default)(headers)));

        this.defer.reject(new Error("TURN_DISCOVERY_RESPONSE missing some headers: ".concat((0, _stringify.default)(headers))));
      } else {
        _loggerProxy.default.logger.info("Roap:turnDiscovery#handleTurnDiscoveryResponse --> received a valid response, url=".concat(this.turnInfo.url));

        this.defer.resolve();
      }
    }
    /**
     * sends the TURN_DISCOVERY_REQUEST roap request
     *
     * @param {Meeting} meeting
     * @param {Boolean} isReconnecting
     * @returns {Promise}
     * @private
     * @memberof Roap
     */

  }, {
    key: "sendRoapTurnDiscoveryRequest",
    value: function sendRoapTurnDiscoveryRequest(meeting, isReconnecting) {
      var seq = meeting.roapSeq + 1;

      if (this.defer) {
        _loggerProxy.default.logger.warn('Roap:turnDiscovery#sendRoapTurnDiscoveryRequest --> already in progress');

        return _promise.default.resolve();
      }

      this.defer = new _common.Defer();
      var roapMessage = {
        messageType: _constants2.ROAP.ROAP_TYPES.TURN_DISCOVERY_REQUEST,
        version: _constants2.ROAP.ROAP_VERSION,
        seq: seq
      };

      _loggerProxy.default.logger.info('Roap:turnDiscovery#sendRoapTurnDiscoveryRequest --> sending TURN_DISCOVERY_REQUEST');

      return this.roapRequest.sendRoap({
        roapMessage: roapMessage,
        correlationId: meeting.correlationId,
        locusSelfUrl: meeting.selfUrl,
        mediaId: isReconnecting ? '' : meeting.mediaId,
        audioMuted: meeting.isAudioMuted(),
        videoMuted: meeting.isVideoMuted(),
        meetingId: meeting.id
      }).then(function (_ref) {
        var mediaConnections = _ref.mediaConnections;
        meeting.setRoapSeq(seq);

        if (mediaConnections) {
          meeting.updateMediaConnections(mediaConnections);
        }
      });
    }
    /**
     * Sends the OK message that server expects to receive
     * after it sends us TURN_DISCOVERY_RESPONSE
     *
     * @param {Meeting} meeting
     * @returns {Promise}
     */

  }, {
    key: "sendRoapOK",
    value: function sendRoapOK(meeting) {
      _loggerProxy.default.logger.info('Roap:turnDiscovery#sendRoapOK --> sending OK');

      return this.roapRequest.sendRoap({
        roapMessage: {
          messageType: _constants2.ROAP.ROAP_TYPES.OK,
          version: _constants2.ROAP.ROAP_VERSION,
          seq: meeting.roapSeq
        },
        locusSelfUrl: meeting.selfUrl,
        mediaId: meeting.mediaId,
        correlationId: meeting.correlationId,
        audioMuted: meeting.isAudioMuted(),
        videoMuted: meeting.isVideoMuted(),
        meetingId: meeting.id
      });
    }
    /**
     * Retrieves TURN server information from the backend by doing
     * a roap message exchange:
     * client                             server
     *  | -----TURN_DISCOVERY_REQUEST-----> |
     *  | <----TURN_DISCOVERY_RESPONSE----- |
     *  | --------------OK----------------> |
     *
     * @param {Meeting} meeting
     * @param {Boolean} isReconnecting should be set to true if this is a new
     *                                 media connection just after a reconnection
     * @returns {Promise}
     */

  }, {
    key: "doTurnDiscovery",
    value: function doTurnDiscovery(meeting, isReconnecting) {
      var _this2 = this;

      if (!meeting.config.experimental.enableTurnDiscovery) {
        _loggerProxy.default.logger.info('Roap:turnDiscovery#doTurnDiscovery --> TURN discovery disabled in config, skipping it');

        return _promise.default.resolve(undefined);
      }

      return this.sendRoapTurnDiscoveryRequest(meeting, isReconnecting).then(function () {
        return _this2.waitForTurnDiscoveryResponse();
      }).then(function () {
        return _this2.sendRoapOK(meeting);
      }).then(function () {
        _this2.defer = undefined;

        _loggerProxy.default.logger.info('Roap:turnDiscovery#doTurnDiscovery --> TURN discovery completed');

        return _this2.turnInfo;
      }).catch(function (e) {
        // we catch any errors and resolve with no turn information so that the normal call join flow can continue without TURN
        _loggerProxy.default.logger.info("Roap:turnDiscovery#doTurnDiscovery --> TURN discovery failed, continuing without TURN: ".concat(e));

        _metrics.default.sendBehavioralMetric(_constants.default.TURN_DISCOVERY_FAILURE, {
          correlation_id: meeting.correlationId,
          locus_id: meeting.locusUrl.split('/').pop(),
          reason: e.message,
          stack: e.stack
        });

        return _promise.default.resolve(undefined);
      });
    }
  }]);
  return TurnDiscovery;
}();

exports.default = TurnDiscovery;
//# sourceMappingURL=turnDiscovery.js.map
