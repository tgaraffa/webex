"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _constants = require("../constants");

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var SelfUtils = {};
var PSTN_DEVICE_TYPE = 'PROVISIONAL';
/**
 * parses the relevant values for self: muted, guest, moderator, mediaStatus, state, joinedWith, pstnDevices, creator, id
 * @param {Object} self
 * @param {String} deviceId
 * @returns {undefined}
 */

SelfUtils.parse = function (self, deviceId) {
  if (self) {
    var _joinedWith$intent;

    var joinedWith = self.devices.find(function (device) {
      return deviceId === device.url;
    });
    var pstnDevices = self.devices.filter(function (device) {
      return PSTN_DEVICE_TYPE === device.deviceType;
    });
    return {
      remoteMuted: SelfUtils.getRemoteMuted(self),
      unmuteAllowed: SelfUtils.getUnmuteAllowed(self),
      localAudioUnmuteRequested: SelfUtils.getLocalAudioUnmuteRequested(self),
      localAudioUnmuteRequired: SelfUtils.getLocalAudioUnmuteRequired(self),
      lastModified: SelfUtils.getLastModified(self),
      modifiedBy: SelfUtils.getModifiedBy(self),
      guest: self.guest,
      moderator: self.moderator,
      // cumulative media stats
      mediaStatus: SelfUtils.getStatus(self.status),
      // TODO: what should be the status if user has refreshed the page,
      // check the joinedWith parameter and communicate to the user
      state: self.state,
      // TODO: give a proper name . With same device as login or different login`
      // Some times we might have joined with both mobile and web
      joinedWith: joinedWith,
      pstnDevices: pstnDevices,
      // current media stats is for the current device who has joined
      currentMediaStatus: SelfUtils.getMediaStatus(joinedWith === null || joinedWith === void 0 ? void 0 : joinedWith.mediaSessions),
      creator: self.isCreator,
      // check if its used,
      selfId: self.id,
      selfIdentity: SelfUtils.getSelfIdentity(self),
      selfUrl: self.url,
      removed: self.removed,
      roles: SelfUtils.getRoles(self),
      isUserUnadmitted: self.state === _constants._IDLE_ && (joinedWith === null || joinedWith === void 0 ? void 0 : (_joinedWith$intent = joinedWith.intent) === null || _joinedWith$intent === void 0 ? void 0 : _joinedWith$intent.type) === _constants._WAIT_,
      layout: SelfUtils.getLayout(self)
    };
  }

  return null;
};

SelfUtils.getLayout = function (self) {
  var _self$controls;

  return (0, _isArray.default)(self === null || self === void 0 ? void 0 : (_self$controls = self.controls) === null || _self$controls === void 0 ? void 0 : _self$controls.layouts) ? self.controls.layouts[0].type : undefined;
};

SelfUtils.getRoles = function (self) {
  var _self$controls2, _self$controls2$role;

  return ((self === null || self === void 0 ? void 0 : (_self$controls2 = self.controls) === null || _self$controls2 === void 0 ? void 0 : (_self$controls2$role = _self$controls2.role) === null || _self$controls2$role === void 0 ? void 0 : _self$controls2$role.roles) || []).reduce(function (roles, role) {
    if (role.hasRole) {
      roles.push(role.type);
    }

    return roles;
  }, []);
};

SelfUtils.getSelves = function (oldSelf, newSelf, deviceId) {
  var previous = oldSelf && SelfUtils.parse(oldSelf, deviceId);
  var current = newSelf && SelfUtils.parse(newSelf, deviceId);
  var updates = {};
  updates.isUserUnadmitted = SelfUtils.isUserUnadmitted(current);
  updates.isUserAdmitted = SelfUtils.isUserAdmitted(previous, current);
  updates.isMutedByOthersChanged = SelfUtils.mutedByOthersChanged(previous, current);
  updates.localAudioUnmuteRequestedByServer = SelfUtils.localAudioUnmuteRequestedByServer(previous, current);
  updates.localAudioUnmuteRequiredByServer = SelfUtils.localAudioUnmuteRequiredByServer(previous, current);
  updates.moderatorChanged = SelfUtils.moderatorChanged(previous, current);
  updates.isMediaInactiveOrReleased = SelfUtils.wasMediaInactiveOrReleased(previous, current);
  updates.isUserObserving = SelfUtils.isDeviceObserving(previous, current);
  updates.layoutChanged = SelfUtils.layoutChanged(previous, current);
  updates.isMediaInactive = SelfUtils.isMediaInactive(previous, current);
  updates.audioStateChange = (previous === null || previous === void 0 ? void 0 : previous.currentMediaStatus.audio) !== current.currentMediaStatus.audio;
  updates.videoStateChange = (previous === null || previous === void 0 ? void 0 : previous.currentMediaStatus.video) !== current.currentMediaStatus.video;
  updates.shareStateChange = (previous === null || previous === void 0 ? void 0 : previous.currentMediaStatus.share) !== current.currentMediaStatus.share;
  return {
    previous: previous,
    current: current,
    updates: updates
  };
};
/**
 * Checks if user has joined the meeting
 * @param {Object} self
 * @returns {boolean} isJoined
*/


SelfUtils.isJoined = function (self) {
  return (self === null || self === void 0 ? void 0 : self.state) === _constants._JOINED_;
};
/**
 * Validate if the Meeting Layout Controls Layout has changed.
 *
 * @param {Self} previous - Previous self state
 * @param {Self} current - Current self state [per event]
 * @returns {boolean} - If the MEeting Layout Controls Layout has changed.
 */


SelfUtils.layoutChanged = function (previous, current) {
  return (current === null || current === void 0 ? void 0 : current.layout) && (previous === null || previous === void 0 ? void 0 : previous.layout) !== (current === null || current === void 0 ? void 0 : current.layout);
};

SelfUtils.isMediaInactive = function (previous, current) {
  if (previous && previous.joinedWith && previous.joinedWith.mediaSessions && current && current.joinedWith && current.joinedWith.mediaSessions) {
    var previousMediaStatus = SelfUtils.getMediaStatus(previous.joinedWith.mediaSessions);
    var currentMediaStatus = SelfUtils.getMediaStatus(current.joinedWith.mediaSessions);

    if (previousMediaStatus.audio && currentMediaStatus.audio && previousMediaStatus.audio.state !== _constants.MEDIA_STATE.inactive && currentMediaStatus.audio.state === _constants.MEDIA_STATE.inactive && currentMediaStatus.audio.direction !== _constants.MEDIA_STATE.inactive) {
      return true;
    }

    if (previousMediaStatus.video && currentMediaStatus.video && previousMediaStatus.video.state !== _constants.MEDIA_STATE.inactive && currentMediaStatus.video.state === _constants.MEDIA_STATE.inactive && currentMediaStatus.video.direction !== _constants.MEDIA_STATE.inactive) {
      return true;
    }

    if (previousMediaStatus.share && currentMediaStatus.share && previousMediaStatus.share.state !== _constants.MEDIA_STATE.inactive && currentMediaStatus.share.state === _constants.MEDIA_STATE.inactive && currentMediaStatus.share.direction !== _constants.MEDIA_STATE.inactive) {
      return true;
    }

    return false;
  }

  return false;
};

SelfUtils.getLastModified = function (self) {
  if (!self || !self.controls || !self.controls.audio || !self.controls.audio.meta || !self.controls.audio.meta.lastModified) {
    return null;
  }

  return self.controls.audio.meta.lastModified;
};

SelfUtils.getModifiedBy = function (self) {
  if (!self || !self.controls || !self.controls.audio || !self.controls.audio.meta || !self.controls.audio.meta.modifiedBy) {
    return null;
  }

  return self.controls.audio.meta.modifiedBy;
};
/**
 * get the id from the self object
 * @param {Object} self
 * @returns {String}
 */


SelfUtils.getSelfIdentity = function (self) {
  if (!self && !self.person) {
    return null;
  }

  return self.person.id;
};
/**
 * get the "remote mute" property from the self object
 * @param {Object} self
 * @returns {Boolean}
 */


SelfUtils.getRemoteMuted = function (self) {
  if (!self || !self.controls || !self.controls.audio) {
    return null;
  }

  return self.controls.audio.muted;
};

SelfUtils.getLocalAudioUnmuteRequested = function (self) {
  var _self$controls3, _self$controls3$audio;

  return !!(self !== null && self !== void 0 && (_self$controls3 = self.controls) !== null && _self$controls3 !== void 0 && (_self$controls3$audio = _self$controls3.audio) !== null && _self$controls3$audio !== void 0 && _self$controls3$audio.requestedToUnmute);
};

SelfUtils.getUnmuteAllowed = function (self) {
  if (!self || !self.controls || !self.controls.audio) {
    return null;
  }

  return !self.controls.audio.disallowUnmute;
};

SelfUtils.getLocalAudioUnmuteRequired = function (self) {
  var _self$controls4, _self$controls4$audio;

  return !!(self !== null && self !== void 0 && (_self$controls4 = self.controls) !== null && _self$controls4 !== void 0 && (_self$controls4$audio = _self$controls4.audio) !== null && _self$controls4$audio !== void 0 && _self$controls4$audio.localAudioUnmuteRequired);
};

SelfUtils.getStatus = function (status) {
  return {
    audio: status.audioStatus,
    video: status.videoStatus,
    slides: status.videoSlidesStatus
  };
};
/**
 * @param {Object} oldSelf
 * @param {Object} changedSelf
 * @returns {Boolean}
 */


SelfUtils.wasMediaInactiveOrReleased = function () {
  var oldSelf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var changedSelf = arguments.length > 1 ? arguments[1] : undefined;
  return oldSelf.joinedWith && oldSelf.joinedWith.state === _constants._JOINED_ && changedSelf.joinedWith.state === _constants._LEFT_ && (changedSelf.joinedWith.reason === _constants.MEETING_END_REASON.INACTIVE || changedSelf.joinedWith.reason === _constants.MEETING_END_REASON.MEDIA_RELEASED);
};
/**
 * @param {Object} check
 * @returns {Boolean}
 */


SelfUtils.isLocusUserUnadmitted = function (check) {
  var _check$joinedWith, _check$joinedWith$int;

  return check && ((_check$joinedWith = check.joinedWith) === null || _check$joinedWith === void 0 ? void 0 : (_check$joinedWith$int = _check$joinedWith.intent) === null || _check$joinedWith$int === void 0 ? void 0 : _check$joinedWith$int.type) === _constants._WAIT_ && check.state === _constants._IDLE_;
};
/**
 * @param {Object} check
 * @returns {Boolean}
 */


SelfUtils.isLocusUserAdmitted = function (check) {
  var _check$joinedWith2, _check$joinedWith2$in;

  return check && ((_check$joinedWith2 = check.joinedWith) === null || _check$joinedWith2 === void 0 ? void 0 : (_check$joinedWith2$in = _check$joinedWith2.intent) === null || _check$joinedWith2$in === void 0 ? void 0 : _check$joinedWith2$in.type) !== _constants._WAIT_ && check.state === _constants._JOINED_;
};
/**
 * @param {Object} self
 * @returns {Boolean}
 * @throws {Error} when self is undefined
 */


SelfUtils.isUserUnadmitted = function (self) {
  if (!self) {
    throw new _parameter.default('self must be defined to determine if self is unadmitted as guest.');
  }

  return SelfUtils.isLocusUserUnadmitted(self);
};

SelfUtils.moderatorChanged = function (oldSelf, changedSelf) {
  if (!oldSelf) {
    return true;
  }

  if (!changedSelf) {
    throw new _parameter.default('New self must be defined to determine if self transitioned moderator status.');
  }

  return oldSelf.moderator !== changedSelf.moderator;
};
/**
 * @param {Object} oldSelf
 * @param {Object} changedSelf
 * @returns {Boolean}
 * @throws {Error} if changed self was undefined
 */


SelfUtils.isDeviceObserving = function (oldSelf, changedSelf) {
  var _oldSelf$joinedWith, _oldSelf$joinedWith$i, _changedSelf$joinedWi, _changedSelf$joinedWi2;

  return oldSelf && ((_oldSelf$joinedWith = oldSelf.joinedWith) === null || _oldSelf$joinedWith === void 0 ? void 0 : (_oldSelf$joinedWith$i = _oldSelf$joinedWith.intent) === null || _oldSelf$joinedWith$i === void 0 ? void 0 : _oldSelf$joinedWith$i.type) === _constants._MOVE_MEDIA_ && changedSelf && ((_changedSelf$joinedWi = changedSelf.joinedWith) === null || _changedSelf$joinedWi === void 0 ? void 0 : (_changedSelf$joinedWi2 = _changedSelf$joinedWi.intent) === null || _changedSelf$joinedWi2 === void 0 ? void 0 : _changedSelf$joinedWi2.type) === _constants._OBSERVE_;
};
/**
 * @param {Object} oldSelf
 * @param {Object} changedSelf
 * @returns {Boolean}
 * @throws {Error} if changed self was undefined
 */


SelfUtils.isUserAdmitted = function (oldSelf, changedSelf) {
  if (!oldSelf) {
    // if there was no previous locus, it couldn't have been admitted yet
    return false;
  }

  if (!changedSelf) {
    throw new _parameter.default('New self must be defined to determine if self transitioned to admitted as guest.');
  }

  return SelfUtils.isLocusUserUnadmitted(oldSelf) && SelfUtils.isLocusUserAdmitted(changedSelf);
};

SelfUtils.mutedByOthersChanged = function (oldSelf, changedSelf) {
  if (!changedSelf) {
    throw new _parameter.default('New self must be defined to determine if self was muted by others.');
  }

  if (!oldSelf || oldSelf.remoteMuted === null) {
    if (changedSelf.remoteMuted) {
      return true; // this happens when mute on-entry is enabled
    } // we don't want to be sending the 'meeting:self:unmutedByOthers' notification on meeting join


    return false;
  }

  return changedSelf.remoteMuted !== null && (oldSelf.remoteMuted !== changedSelf.remoteMuted || changedSelf.remoteMuted && oldSelf.unmuteAllowed !== changedSelf.unmuteAllowed);
};

SelfUtils.localAudioUnmuteRequestedByServer = function () {
  var oldSelf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var changedSelf = arguments.length > 1 ? arguments[1] : undefined;

  if (!changedSelf) {
    throw new _parameter.default('New self must be defined to determine if self received request to unmute.');
  }

  return changedSelf.localAudioUnmuteRequested && !oldSelf.localAudioUnmuteRequested;
};

SelfUtils.localAudioUnmuteRequiredByServer = function () {
  var oldSelf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var changedSelf = arguments.length > 1 ? arguments[1] : undefined;

  if (!changedSelf) {
    throw new _parameter.default('New self must be defined to determine if localAudioUnmuteRequired changed.');
  }

  return !changedSelf.remoteMuted && changedSelf.localAudioUnmuteRequired && oldSelf.localAudioUnmuteRequired !== changedSelf.localAudioUnmuteRequired;
};
/**
 * extract the sipUrl from the partner
 * @param {Object} partner
 * @param {Object} info
 * @returns {Object}
 */


SelfUtils.getSipUrl = function (partner, type, sipUri) {
  // For webex meeting the sipUrl gets updated in info parser
  if (partner && type === _constants._CALL_) {
    return {
      sipUri: partner.person.sipUrl || partner.person.id
    };
  }

  return {
    sipUri: sipUri
  };
};

SelfUtils.getMediaStatus = function () {
  var mediaSessions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var mediaStatus = {
    audio: {},
    video: {},
    share: {}
  };
  mediaStatus.audio = mediaSessions.find(function (media) {
    return media.mediaType === _constants.AUDIO && media.mediaContent === _constants.MediaContent.main;
  });
  mediaStatus.video = mediaSessions.find(function (media) {
    return media.mediaType === _constants.VIDEO && media.mediaContent === _constants.MediaContent.main;
  });
  mediaStatus.share = mediaSessions.find(function (media) {
    return media.mediaType === _constants.VIDEO && media.mediaContent === _constants.MediaContent.slides;
  });
  return mediaStatus;
};

var _default = SelfUtils;
exports.default = _default;
//# sourceMappingURL=selfUtils.js.map
