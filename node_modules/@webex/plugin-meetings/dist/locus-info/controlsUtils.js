"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }

var ControlsUtils = {};
/**
 * Controls
 * @typedef {Object} LocusControls
 * @property {Object} record
 * @property {Boolean} record.recording
 * @property {Object} record.meta
 * @property {String} record.meta.modifiedBy
 */

/**
 * parse the relevant host values that we care about: id
 * @param {LocusControls} controls
 * @returns {Object} parsedObject - parsed host or null if host was undefined
 * @returns {String} parsedObject.recordingId
 */

ControlsUtils.parse = function (controls) {
  var parsedControls = _objectSpread({}, controls);

  if (controls && controls.record) {
    parsedControls.record = {
      modifiedBy: ControlsUtils.getId(controls),
      paused: controls.record.paused ? controls.record.paused : false,
      recording: controls.record.recording,
      lastModified: controls.record.meta.lastModified
    };
  }

  if (controls && controls.meetingContainer) {
    parsedControls.meetingContainer = {
      meetingContainerUrl: controls.meetingContainer.meetingContainerUrl
    };
  }

  if (controls && controls.transcribe) {
    parsedControls.transcribe = {
      transcribing: controls.transcribe.transcribing,
      caption: controls.transcribe.caption
    };
  }

  return parsedControls;
};
/**
 * parses and returns previous state vs current state and triggers the changes.
 * @param {LocusControl} oldControls previous state
 * @param {LocusControl} newControls current state
 * @returns {Object} combination of state plus the changes
 */


ControlsUtils.getControls = function (oldControls, newControls) {
  var _previous$record, _previous$record2, _current$record, _previous$record3, _current$record2, _previous$record4, _current$record3, _previous$meetingCont, _current$meetingConta, _previous$transcribe, _current$transcribe, _previous$transcribe2, _current$transcribe2;

  var previous = ControlsUtils.parse(oldControls);
  var current = ControlsUtils.parse(newControls);
  return {
    previous: previous,
    current: current,
    updates: {
      hasRecordingPausedChanged: (current === null || current === void 0 ? void 0 : current.record) && !(0, _isEqual2.default)(previous === null || previous === void 0 ? void 0 : (_previous$record = previous.record) === null || _previous$record === void 0 ? void 0 : _previous$record.paused, current.record.paused) && ((previous === null || previous === void 0 ? void 0 : (_previous$record2 = previous.record) === null || _previous$record2 === void 0 ? void 0 : _previous$record2.recording) || (current === null || current === void 0 ? void 0 : (_current$record = current.record) === null || _current$record === void 0 ? void 0 : _current$record.recording)),
      // see comments directly below
      hasRecordingChanged: (current === null || current === void 0 ? void 0 : current.record) && !(0, _isEqual2.default)(previous === null || previous === void 0 ? void 0 : (_previous$record3 = previous.record) === null || _previous$record3 === void 0 ? void 0 : _previous$record3.recording, current === null || current === void 0 ? void 0 : (_current$record2 = current.record) === null || _current$record2 === void 0 ? void 0 : _current$record2.recording) && ( // upon first join, previous?.record?.recording = undefined; thus, never going to be equal and will always return true
      (previous === null || previous === void 0 ? void 0 : (_previous$record4 = previous.record) === null || _previous$record4 === void 0 ? void 0 : _previous$record4.recording) || (current === null || current === void 0 ? void 0 : (_current$record3 = current.record) === null || _current$record3 === void 0 ? void 0 : _current$record3.recording)),
      // therefore, condition added to prevent false firings of #meeting:recording:stopped upon first joining a meeting
      hasMeetingContainerChanged: (current === null || current === void 0 ? void 0 : current.meetingContainer) && !(0, _isEqual2.default)(previous === null || previous === void 0 ? void 0 : (_previous$meetingCont = previous.meetingContainer) === null || _previous$meetingCont === void 0 ? void 0 : _previous$meetingCont.meetingContainerUrl, current === null || current === void 0 ? void 0 : (_current$meetingConta = current.meetingContainer) === null || _current$meetingConta === void 0 ? void 0 : _current$meetingConta.meetingContainerUrl),
      hasTranscribeChanged: (current === null || current === void 0 ? void 0 : current.transcribe) && !(0, _isEqual2.default)(previous === null || previous === void 0 ? void 0 : (_previous$transcribe = previous.transcribe) === null || _previous$transcribe === void 0 ? void 0 : _previous$transcribe.transcribing, current === null || current === void 0 ? void 0 : (_current$transcribe = current.transcribe) === null || _current$transcribe === void 0 ? void 0 : _current$transcribe.transcribing) && ( // upon first join, previous?.record?.recording = undefined; thus, never going to be equal and will always return true
      (previous === null || previous === void 0 ? void 0 : (_previous$transcribe2 = previous.transcribe) === null || _previous$transcribe2 === void 0 ? void 0 : _previous$transcribe2.transcribing) || (current === null || current === void 0 ? void 0 : (_current$transcribe2 = current.transcribe) === null || _current$transcribe2 === void 0 ? void 0 : _current$transcribe2.transcribing)) // therefore, condition added to prevent false firings of #meeting:recording:stopped upon first joining a meeting

    }
  };
};
/**
 * Extract the id from the record controls object
 * @param {LocusControls} controls
 * @returns {String|null}
 */


ControlsUtils.getId = function (controls) {
  if (controls.record.meta) {
    return controls.record.meta.modifiedBy;
  }

  return null;
};

var _default = ControlsUtils;
exports.default = _default;
//# sourceMappingURL=controlsUtils.js.map
