"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

require("@webex/internal-plugin-mercury");

require("@webex/internal-plugin-conversation");

var _webexCore = require("@webex/webex-core");

require("webrtc-adapter");

var _metrics = _interopRequireDefault(require("../metrics"));

var _config = require("../metrics/config");

var _loggerConfig = _interopRequireDefault(require("../common/logs/logger-config"));

var _config2 = _interopRequireDefault(require("../common/config"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _request = _interopRequireDefault(require("../common/logs/request"));

var _triggerProxy = _interopRequireDefault(require("../common/events/trigger-proxy"));

var _media = _interopRequireDefault(require("../media"));

var _util = _interopRequireDefault(require("../meeting/util"));

var _constants = require("../constants");

var _constants2 = _interopRequireDefault(require("../metrics/constants"));

var _meetingInfo = _interopRequireDefault(require("../meeting-info"));

var _meetingInfoV = _interopRequireDefault(require("../meeting-info/meeting-info-v2"));

var _meeting = _interopRequireDefault(require("../meeting"));

var _personalMeetingRoom = _interopRequireDefault(require("../personal-meeting-room"));

var _reachability = _interopRequireDefault(require("../reachability"));

var _request2 = _interopRequireDefault(require("../meetings/request"));

var _passwordError = _interopRequireDefault(require("../common/errors/password-error"));

var _captchaError = _interopRequireDefault(require("../common/errors/captcha-error"));

var _collection = _interopRequireDefault(require("./collection"));

var _util2 = _interopRequireDefault(require("./util"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
   * Meetings Ready Event
   * Emitted when the meetings instance on webex is ready
   * @event meetings:ready
   * @instance
   * @memberof Meetings
   */

/**
   * Meetings Network Disconnected Event
   * Emitted when the meetings instance is disconnected from
   * the internal mercury server
   * @event network:disconnected
   * @instance
   * @memberof Meetings
   */

/**
 * Meetings Registered Event
 * Emitted when the meetings instance has been registered and listening
 * @event meetings:registered
 * @instance
 * @memberof Meetings
 */

/**
    * Meeting Removed Event
    * Emitted when a meeting was removed from the cache of meetings
    * @event meeting:removed
    * @instance
    * @type {Object}
    * @property {String} meetingId the removed meeting
    * @property {Object} response the server response
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
    * Meeting Added Event
    * Emitted when a meeting was added to the cache of meetings
    * @event meeting:added
    * @instance
    * @type {Object}
    * @property {String} meetingId the added meeting
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
   * Maintain a cache of meetings and sync with services.
   * @class
   */
var Meetings = /*#__PURE__*/function (_WebexPlugin) {
  (0, _inherits2.default)(Meetings, _WebexPlugin);

  var _super = _createSuper(Meetings);

  /**
     * Initializes the Meetings Plugin
     * @constructor
     * @public
     * @memberof Meetings
     */
  function Meetings() {
    var _this;

    (0, _classCallCheck2.default)(this, Meetings);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    /**
       * The Meetings request to interact with server
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */

    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "namespace", _constants.MEETINGS);
    _this.request = new _request2.default({}, {
      parent: _this.webex
    });
    /**
       * Log upload request helper
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */

    _this.loggerRequest = new _request.default({
      webex: _this.webex
    });
    _this.meetingCollection = new _collection.default();
    /**
       * The PersonalMeetingRoom object to interact with server
       * @instance
       * @type {Object}
       * @public
       * @memberof Meetings
       */

    _this.personalMeetingRoom = null;
    /**
       * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
       * starts as null
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */

    _this.reachability = null;
    /**
       * If the meetings plugin has been registered and listening via {@link Meetings#register}
       * @instance
       * @type {Boolean}
       * @public
       * @memberof Meetings
       */

    _this.registered = false;
    /**
       * This values indicates the preferred webex site the user will start there meeting, getsits value from {@link Meetings#register}
       * @instance
       * @type {String}
       * @private
       * @memberof Meetings
       */

    _this.preferredWebexSite = '';
    /**
       * The public interface for the internal Media util files. These are helpful to expose outside the context
       * of a meeting so that a user can access media without creating a meeting instance.
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */

    _this.media = {
      getUserMedia: _media.default.getUserMedia,
      getSupportedDevice: _media.default.getSupportedDevice
    };

    _this.onReady();

    return _this;
  }
  /**
     * handle locus events and takes meeting actions with them as they come in
     * @param {Object} data a locus event
     * @param {String} data.locusUrl
     * @param {Object} data.locus
     * @param {Boolean} useRandomDelayForInfo whether a random delay should be added to fetching meeting info
     * @param {String} data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */


  (0, _createClass2.default)(Meetings, [{
    key: "handleLocusEvent",
    value: function handleLocusEvent(data) {
      var _data$locus$info,
          _data$locus,
          _data$locus$replaces,
          _this2 = this;

      var useRandomDelayForInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var meeting = null; // getting meeting by correlationId. This will happen for the new event
      // Either the locus
      // TODO : Add check for the callBack Address

      meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locusUrl) || this.meetingCollection.getByKey(_constants.CORRELATION_ID, _util2.default.checkForCorrelationId(this.webex.internal.device.url, data.locus)) || this.meetingCollection.getByKey(_constants.SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress) || ((_data$locus$info = data.locus.info) !== null && _data$locus$info !== void 0 && _data$locus$info.isUnifiedSpaceMeeting ? undefined : this.meetingCollection.getByKey(_constants.CONVERSATION_URL, data.locus.conversationUrl)); // Special case when locus has got replaced, This only happend once if a replace locus exists
      // https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-changing-mid-call

      if (!meeting && ((_data$locus = data.locus) === null || _data$locus === void 0 ? void 0 : (_data$locus$replaces = _data$locus.replaces) === null || _data$locus$replaces === void 0 ? void 0 : _data$locus$replaces.length) > 0) {
        // Always the last element in the replace is the active one
        meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locus.replaces[data.locus.replaces.length - 1].locusUrl);
      }

      if (!meeting) {
        // TODO: create meeting when we get a meeting object
        // const checkForEnded = (locus) => {
        // TODO: you already ended the meeting but you got an event later
        // Mainly for 1:1 Callsor meeting
        // Happens mainly after refresh
        // 1:1 Meeting
        // 1)  You ended a call before but you got a mercury event
        // Make sure end the call and cleanup the meeting only if the mercury
        // event says so
        // 2) Maintain lastSync time in the meetings object which helps to compare
        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid
        // For space Meeting
        // Check the locus object and see who has joined
        // };
        // rather then locus object change to locus url
        if (data.locus && data.locus.fullState && data.locus.fullState.state === _constants.LOCUS.STATE.INACTIVE) {
          // just ignore the event as its already ended and not active
          _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');

          return;
        } // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object
        // Any future events will be neglected


        if (data.locus && data.locus.self && data.locus.self.state === _constants._LEFT_ && data.locus.self.removed === true) {
          // just ignore the event as its already ended and not active
          _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');

          return;
        }

        this.create(data.locus, _constants._LOCUS_ID_, useRandomDelayForInfo).then(function (newMeeting) {
          meeting = newMeeting; // It's a new meeting so initialize the locus data

          meeting.locusInfo.initialSetup(data.locus);
        }).catch(function (e) {
          console.log(e);
        }).finally(function () {
          // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted
          // because the other user left so before sending 'added' event make sure it exists in the collection
          if (_this2.getMeetingByType(_constants._ID_, meeting.id)) {
            _metrics.default.postEvent({
              event: _config.eventType.REMOTE_STARTED,
              meeting: meeting,
              data: {
                trigger: _config.trigger.MERCURY_EVENT
              }
            });

            _triggerProxy.default.trigger(_this2, {
              file: 'meetings',
              function: 'handleLocusEvent'
            }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
              meeting: meeting,
              type: meeting.type === _constants._MEETING_ ? _constants._JOIN_ : _constants._INCOMING_
            });
          } else {
            // Meeting got added but was not found in the collection. It might have got destroyed
            _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Created and destroyed meeting object before sending an event');
          }
        });
      } else {
        meeting.locusInfo.parse(meeting, data);
      }
    }
    /**
       * handles locus events through mercury that are not roap
       * @param {Object} envelope
       * @param {Object} envelope.data
       * @param {String} envelope.data.eventType
       * @returns {undefined}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "handleLocusMercury",
    value: function handleLocusMercury(envelope) {
      var data = envelope.data;
      var eventType = data.eventType;

      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {
        this.handleLocusEvent(data, true);
      }
    }
    /**
       * handles mecury offline event
       * @returns {undefined}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "handleMercuryOffline",
    value: function handleMercuryOffline() {
      _triggerProxy.default.trigger(this, {
        file: 'meetings/index',
        function: 'handleMercuryOffline'
      }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED);
    }
    /**
       * registers for locus and roap mercury events
       * @returns {undefined}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "listenForEvents",
    value: function listenForEvents() {
      var _this3 = this;

      this.webex.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {
        _this3.handleLocusMercury(envelope);
      });
      this.webex.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {
        _util2.default.handleRoapMercury(envelope, _this3.meetingCollection);
      });
      this.webex.internal.mercury.on(_constants.ONLINE, function () {
        _this3.syncMeetings();
      });
      this.webex.internal.mercury.on(_constants.OFFLINE, function () {
        _this3.handleMercuryOffline();
      });
    }
    /**
       * stops listening for locus and roap mercury events
       * @returns {undefined}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "stopListeningForEvents",
    value: function stopListeningForEvents() {
      this.webex.internal.mercury.off(_constants.LOCUSEVENT.LOCUS_MERCURY);
      this.webex.internal.mercury.off(_constants.ROAP.ROAP_MERCURY);
      this.webex.internal.mercury.off(_constants.ONLINE);
    }
    /**
       * @returns {undefined}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "onReady",
    value: function onReady() {
      var _this4 = this;

      this.webex.once(_constants.READY, function () {
        _config2.default.set(_this4.config);

        _loggerConfig.default.set(_this4.config.logging);

        _loggerProxy.default.set(_this4.webex.logger);
        /**
         * The MeetingInfo object to interact with server
         * @instance
         * @type {Object}
         * @private
         * @memberof Meetings
         */


        _this4.meetingInfo = _this4.config.experimental.enableUnifiedMeetings ? new _meetingInfoV.default(_this4.webex) : new _meetingInfo.default(_this4.webex);
        _this4.personalMeetingRoom = new _personalMeetingRoom.default({
          meetingInfo: _this4.meetingInfo
        }, {
          parent: _this4.webex
        });

        _triggerProxy.default.trigger(_this4, {
          file: 'meetings',
          function: 'onReady'
        }, _constants.EVENT_TRIGGERS.MEETINGS_READY);

        _util2.default.checkH264Support({
          disableNotifications: true
        });

        _metrics.default.initialSetup(_this4.meetingCollection, _this4.webex);
      });
    }
    /**
       * API to toggle unified meetings
       * @param {Boolean} changeState
       * @private
       * @memberof Meetings
       * @returns {undefined}
      */

  }, {
    key: "_toggleUnifiedMeetings",
    value: function _toggleUnifiedMeetings(changeState) {
      var _this$config, _this$config$experime;

      if (typeof changeState !== 'boolean') {
        return;
      }

      if (((_this$config = this.config) === null || _this$config === void 0 ? void 0 : (_this$config$experime = _this$config.experimental) === null || _this$config$experime === void 0 ? void 0 : _this$config$experime.enableUnifiedMeetings) !== changeState) {
        this.config.experimental.enableUnifiedMeetings = changeState;
        this.meetingInfo = changeState ? new _meetingInfoV.default(this.webex) : new _meetingInfo.default(this.webex);
      }
    }
    /**
       * API to enable or disable TURN discovery
       * @param {Boolean} enable
       * @private
       * @memberof Meetings
       * @returns {undefined}
      */

  }, {
    key: "_toggleTurnDiscovery",
    value: function _toggleTurnDiscovery(enable) {
      if (typeof enable !== 'boolean') {
        return;
      }

      this.config.experimental.enableTurnDiscovery = enable;
    }
    /**
       * API to toggle starting adhoc meeting
       * @param {Boolean} changeState
       * @private
       * @memberof Meetings
       * @returns {undefined}
      */

  }, {
    key: "_toggleAdhocMeetings",
    value: function _toggleAdhocMeetings(changeState) {
      var _this$config2, _this$config2$experim;

      if (typeof changeState !== 'boolean') {
        return;
      }

      if (((_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : (_this$config2$experim = _this$config2.experimental) === null || _this$config2$experim === void 0 ? void 0 : _this$config2$experim.enableAdhocMeetings) !== changeState) {
        this.config.experimental.enableAdhocMeetings = changeState;
      }
    }
    /**
       * Explicitly sets up the meetings plugin by registering
       * the device, connecting to mercury, and listening for locus events.
       *
       * @returns {Promise}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "register",
    value: function register() {
      var _this5 = this;

      if (!this.webex.canAuthorize) {
        _loggerProxy.default.logger.error('Meetings:index#register --> ERROR, Unable to register, SDK cannot authorize');

        return _promise.default.reject(new Error('SDK cannot authorize'));
      }

      if (this.registered) {
        _loggerProxy.default.logger.info('Meetings:index#register --> INFO, Meetings plugin already registered');

        return _promise.default.resolve();
      }

      return _promise.default.all([this.fetchUserPreferredWebexSite(), this.getGeoHint(), this.startReachability().catch(function (error) {
        _loggerProxy.default.logger.error("Meetings:index#register --> GDM error, ".concat(error.message));
      }), this.webex.internal.device.register().then(function () {
        return _loggerProxy.default.logger.info("Meetings:index#register --> INFO, Device registered ".concat(_this5.webex.internal.device.url));
      }).then(function () {
        return _this5.webex.internal.mercury.connect();
      }), _util2.default.checkH264Support.call(this)]).then(function () {
        _this5.listenForEvents();

        _triggerProxy.default.trigger(_this5, {
          file: 'meetings',
          function: 'register'
        }, _constants.EVENT_TRIGGERS.MEETINGS_REGISTERED);

        _this5.registered = true;

        _metrics.default.sendBehavioralMetric(_constants2.default.MEETINGS_REGISTRATION_SUCCESS);
      }).catch(function (error) {
        _loggerProxy.default.logger.error("Meetings:index#register --> ERROR, Unable to register, ".concat(error.message));

        _metrics.default.sendBehavioralMetric(_constants2.default.MEETINGS_REGISTRATION_FAILED, {
          reason: error.message,
          stack: error.stack
        });

        return _promise.default.reject(error);
      });
    }
    /**
       * Explicitly tears down the meetings plugin by deregistering
       * the device, disconnecting from mercury, and stops listening to locus events
       *
       * @returns {Promise}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "unregister",
    value: function unregister() {
      var _this6 = this;

      if (!this.registered) {
        _loggerProxy.default.logger.info('Meetings:index#unregister --> INFO, Meetings plugin already unregistered');

        return _promise.default.resolve();
      }

      this.stopListeningForEvents();
      return this.webex.internal.mercury.disconnect().then(function () {
        return _this6.webex.internal.device.unregister();
      }).then(function () {
        _triggerProxy.default.trigger(_this6, {
          file: 'meetings',
          function: 'unregister'
        }, _constants.EVENT_TRIGGERS.MEETINGS_UNREGISTERED);

        _this6.registered = false;
      });
    }
    /**
       * Uploads logs to the webex services for tracking
       * @param {Object} [options={}]
       * @param {String} [options.callStart] Call Start Time
       * @param {String} [options.feedbackId] ID used for tracking
       * @param {String} [options.locusId]
       * @param {String} [options.correlationId]
       * @param {String} [options.meetingId] webex meeting ID
       * @param {String} [options.userId] userId
       * @param {String} [options.orgId] org id
       * @returns {String} feedback ID logs were submitted under
       */

  }, {
    key: "uploadLogs",
    value: function uploadLogs() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _loggerProxy.default.logger.info('Meetings:index#uploadLogs --> uploading logs');

      return this.loggerRequest.uploadLogs(options).then(function (uploadResult) {
        _loggerProxy.default.logger.info('Meetings:index#uploadLogs --> Upload logs for meeting completed.', uploadResult);

        _triggerProxy.default.trigger(_this7, {
          file: 'meetings',
          function: 'uploadLogs'
        }, _constants.EVENT_TRIGGERS.MEETING_LOG_UPLOAD_SUCCESS, {
          meetingId: options.meetingId,
          details: uploadResult
        });
      }).catch(function (uploadError) {
        _loggerProxy.default.logger.error('Meetings:index#uploadLogs --> Unable to upload logs for meeting', uploadError);

        _triggerProxy.default.trigger(_this7, {
          file: 'meetings',
          function: 'uploadLogs'
        }, _constants.EVENT_TRIGGERS.MEETING_LOG_UPLOAD_FAILURE, {
          meetingId: options.meetingId,
          reason: uploadError
        });

        _metrics.default.sendBehavioralMetric(_constants2.default.UPLOAD_LOGS_FAILURE, {
          meetingId: options.meetingsId,
          reason: uploadError.message,
          stack: uploadError.stack,
          code: uploadError.code
        });
      });
    }
    /**
       * initializes the reachability instance for Meetings
       * @returns {undefined}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "setReachability",
    value: function setReachability() {
      this.reachability = new _reachability.default(this.webex);
    }
    /**
       * gets the reachability instance for Meetings
       * @returns {Reachability}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "getReachability",
    value: function getReachability() {
      return this.reachability;
    }
    /**
       * initializes and starts gathering reachability for Meetings
       * @returns {Promise}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "startReachability",
    value: function startReachability() {
      if (!this.reachability) {
        this.setReachability();
      }

      return this.getReachability().gatherReachability();
    }
    /**
       * Get geoHint for info for meetings
       * @returns {Promise}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "getGeoHint",
    value: function getGeoHint() {
      var _this8 = this;

      return this.request.fetchGeoHint().then(function (res) {
        _this8.geoHintInfo = res;
      });
    }
    /**
       * Fetch user preferred webex site information
       * This also has other infomation about the user
       * @returns {Promise}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "fetchUserPreferredWebexSite",
    value: function fetchUserPreferredWebexSite() {
      var _this9 = this;

      return this.request.getMeetingPreferences().then(function (res) {
        if (res) {
          _this9.preferredWebexSite = _util2.default.parseDefaultSiteFromMeetingPreferences(res);
        }
      });
    }
    /**
       * gets the personal meeting room instance, for saved PMR values for this user
       * @returns {PersonalMeetingRoom}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "getPersonalMeetingRoom",
    value: function getPersonalMeetingRoom() {
      return this.personalMeetingRoom;
    }
    /**
       * @param {Meeting} meeting
       * @param {Object} reason
       * @param {String} type
       * @returns {Undefined}
       * @private
       * @memberof Meetings
       */

  }, {
    key: "destroy",
    value: function destroy(meeting, reason) {
      _util.default.cleanUp(meeting);

      this.meetingCollection.delete(meeting.id);

      _triggerProxy.default.trigger(this, {
        file: 'meetings',
        function: 'destroy'
      }, _constants.EVENT_TRIGGERS.MEETING_REMOVED, {
        meetingId: meeting.id,
        reason: reason
      });
    }
    /**
       * Create a meeting.
       * @param {string} destination - sipURL, spaceId, phonenumber, or locus object}
       * @param {string} [type] - the optional specified type, such as locusId
       * @param {Boolean} useRandomDelayForInfo - whether a random delay should be added to fetching meeting info
       * @returns {Promise<Meeting>} A new Meeting.
       * @public
       * @memberof Meetings
       */

  }, {
    key: "create",
    value: function create(destination) {
      var _this10 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var useRandomDelayForInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // TODO: type should be from a dictionary
      // Validate meeting information based on the provided destination and
      // type. This must be performed prior to determining if the meeting is
      // found in the collection, as we mutate the destination for hydra person
      // id values.
      return this.meetingInfo.fetchInfoOptions(destination, type) // Catch a failure to fetch info options.
      .catch(function (error) {
        _loggerProxy.default.logger.info("Meetings:index#create --> INFO, unable to determine info options: ".concat(error.message));
      }).then(function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Normalize the destination.
        var targetDest = options.destination || destination; // check for the conversation URL then sip Url

        var meeting = null;

        if (type === _constants._CONVERSATION_URL_ || options.type === _constants._CONVERSATION_URL_) {
          var foundMeeting = _this10.meetingCollection.getByKey(_constants.CONVERSATION_URL, targetDest);

          if (foundMeeting) {
            var foundMeetingIsNotCalendarMeeting = !foundMeeting.locusInfo.scheduledMeeting; // If the found meeting is not a calendar meeting, return that meeting.
            // This allows for the creation of instant-meetings when calendar meetings are present.

            if (foundMeetingIsNotCalendarMeeting) {
              meeting = foundMeeting;
            }
          }
        } // Attempt to collect the meeting if it exists.


        if (!meeting) {
          meeting = _this10.meetingCollection.getByKey(_constants.SIP_URI, targetDest);
        } // Validate if a meeting was found.


        if (!meeting) {
          // Create a meeting based on the normalized destination and type.
          return _this10.createMeeting(targetDest, type, useRandomDelayForInfo).then(function (createdMeeting) {
            // If the meeting was successfully created.
            if (createdMeeting && createdMeeting.on) {
              // Create a destruction event for the meeting.
              createdMeeting.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {
                if (_this10.config.autoUploadLogs) {
                  var _createdMeeting$locus, _createdMeeting$locus2, _createdMeeting$locus3, _createdMeeting$locus4;

                  _this10.uploadLogs({
                    callStart: (_createdMeeting$locus = createdMeeting.locusInfo) === null || _createdMeeting$locus === void 0 ? void 0 : (_createdMeeting$locus2 = _createdMeeting$locus.fullState) === null || _createdMeeting$locus2 === void 0 ? void 0 : _createdMeeting$locus2.lastActive,
                    correlationId: createdMeeting.correlationId,
                    feedbackId: createdMeeting.correlationId,
                    locusId: createdMeeting.locusId,
                    meetingId: (_createdMeeting$locus3 = createdMeeting.locusInfo) === null || _createdMeeting$locus3 === void 0 ? void 0 : (_createdMeeting$locus4 = _createdMeeting$locus3.info) === null || _createdMeeting$locus4 === void 0 ? void 0 : _createdMeeting$locus4.webExMeetingId
                  }).then(function () {
                    return _this10.destroy(createdMeeting, payload.reason);
                  });
                } else {
                  _this10.destroy(createdMeeting, payload.reason);
                }
              });
              createdMeeting.on(_constants.EVENTS.REQUEST_UPLOAD_LOGS, function (meetingInstance) {
                if (_this10.config.autoUploadLogs) {
                  var _meetingInstance$locu, _meetingInstance$locu2, _meetingInstance$locu3, _meetingInstance$locu4;

                  _this10.uploadLogs({
                    callStart: meetingInstance === null || meetingInstance === void 0 ? void 0 : (_meetingInstance$locu = meetingInstance.locusInfo) === null || _meetingInstance$locu === void 0 ? void 0 : (_meetingInstance$locu2 = _meetingInstance$locu.fullState) === null || _meetingInstance$locu2 === void 0 ? void 0 : _meetingInstance$locu2.lastActive,
                    correlationId: meetingInstance.correlationId,
                    feedbackId: meetingInstance.correlationId,
                    locusId: meetingInstance.locusId,
                    meetingId: (_meetingInstance$locu3 = meetingInstance.locusInfo) === null || _meetingInstance$locu3 === void 0 ? void 0 : (_meetingInstance$locu4 = _meetingInstance$locu3.info) === null || _meetingInstance$locu4 === void 0 ? void 0 : _meetingInstance$locu4.webExMeetingId
                  });
                }
              });
            } else {
              _loggerProxy.default.logger.error("Meetings:index#create --> ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ".concat(meeting));
            } // Return the newly created meeting.


            return _promise.default.resolve(createdMeeting);
          });
        } // Return the existing meeting.


        return _promise.default.resolve(meeting);
      });
    }
    /**
       * @param {String} destination see create()
       * @param {String} type see create()
       * @param {Boolean} useRandomDelayForInfo whether a random delay should be added to fetching meeting info
       * @returns {Promise} a new meeting instance complete with meeting info and destination
       * @private
       * @memberof Meetings
       */

  }, {
    key: "createMeeting",
    value: function () {
      var _createMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(destination) {
        var type,
            useRandomDelayForInfo,
            meeting,
            _destination$fullStat,
            waitingTime,
            startTime,
            startTimeDate,
            startTimeDatestamp,
            timeToStart,
            maxWaitingTime,
            isMeetingActive,
            enableUnifiedMeetings,
            meetingAddedType,
            _args = arguments;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                type = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                useRandomDelayForInfo = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
                meeting = new _meeting.default({
                  userId: this.webex.internal.device.userId,
                  deviceUrl: this.webex.internal.device.url,
                  orgId: this.webex.internal.device.orgId,
                  roapSeq: 0,
                  locus: type === _constants._LOCUS_ID_ ? destination : null,
                  // pass the locus object if present
                  meetingInfoProvider: this.meetingInfo,
                  destination: destination,
                  destinationType: type
                }, {
                  parent: this.webex
                });
                this.meetingCollection.set(meeting);
                _context.prev = 4;
                // if no participant has joined the scheduled meeting (meaning meeting is not active) and we get a locusEvent,
                // it means the meeting will start in 5-6 min. In that case, we want to fetchMeetingInfo
                // between 5 and 2 min (random between 3 minutes) before the meeting starts
                // to avoid a spike in traffic to the wbxappi service
                waitingTime = 0;

                if (destination.meeting) {
                  startTime = destination.meeting.startTime;
                  startTimeDate = new Date(startTime);
                  startTimeDatestamp = startTimeDate.getTime();
                  timeToStart = startTimeDatestamp - (0, _now.default)();
                  maxWaitingTime = Math.max(Math.min(timeToStart, _constants.MAX_RANDOM_DELAY_FOR_MEETING_INFO), 0);
                  waitingTime = Math.round(Math.random() * maxWaitingTime);
                }

                isMeetingActive = !!((_destination$fullStat = destination.fullState) !== null && _destination$fullStat !== void 0 && _destination$fullStat.active);
                enableUnifiedMeetings = this.config.experimental.enableUnifiedMeetings;

                if (!(enableUnifiedMeetings && !isMeetingActive && useRandomDelayForInfo && waitingTime > 0)) {
                  _context.next = 14;
                  break;
                }

                meeting.fetchMeetingInfoTimeoutId = setTimeout(function () {
                  return meeting.fetchMeetingInfo({});
                }, waitingTime);
                meeting.parseMeetingInfo(undefined, destination);
                _context.next = 16;
                break;

              case 14:
                _context.next = 16;
                return meeting.fetchMeetingInfo({});

              case 16:
                _context.next = 22;
                break;

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](4);

                if (!(_context.t0 instanceof _captchaError.default) && !(_context.t0 instanceof _passwordError.default)) {
                  // if there is no meeting info we assume its a 1:1 call or wireless share
                  _loggerProxy.default.logger.info("Meetings:index#createMeeting --> Info Unable to fetch meeting info for ".concat(destination, "."));

                  _loggerProxy.default.logger.info('Meetings:index#createMeeting --> Info assuming this destination is a 1:1 or wireless share');
                }

                _loggerProxy.default.logger.debug("Meetings:index#createMeeting --> Debug ".concat(_context.t0, " fetching /meetingInfo for creation."));

              case 22:
                _context.prev = 22;

                // For type LOCUS_ID we need to parse the locus object to get the information
                // about the caller and callee
                // Meeting Added event will be created in `handleLocusEvent`
                if (type !== _constants._LOCUS_ID_) {
                  if (!meeting.sipUri) {
                    meeting.setSipUri(destination);
                  } // TODO: check if we have to move this to parser


                  meetingAddedType = _util2.default.getMeetingAddedType(type); // We typically shouldn't need to trigger both and event and return a promise.
                  // Is this a special case? We want to make the public API usage as simple as possible.

                  _triggerProxy.default.trigger(this, {
                    file: 'meetings',
                    function: 'createMeeting'
                  }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
                    meeting: meeting,
                    type: meetingAddedType
                  });
                }

                return _context.finish(22);

              case 25:
                return _context.abrupt("return", meeting);

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 18, 22, 25]]);
      }));

      function createMeeting(_x) {
        return _createMeeting.apply(this, arguments);
      }

      return createMeeting;
    }()
    /**
       * get a specifc meeting given it's type matched to the value, i.e., locus url
       * @param {String} type
       * @param {Object} value
       * @returns {Meeting}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "getMeetingByType",
    value: function getMeetingByType(type, value) {
      return this.meetingCollection.getByKey(type, value);
    }
    /**
       * Get all meetings.
       * @param {object} options
       * @param {object} options.startDate - get meetings after this start date
       * @param {object} options.endDate - get meetings before this end date
       * @returns {Object} All currently active meetings.
       * @public
       * @memberof Meetings
       */

  }, {
    key: "getAllMeetings",
    value: function getAllMeetings() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Options may include other parameters to filter this collection
      // of meetings.
      return this.meetingCollection.getAll(options);
    }
    /**
       * syncs all the meeting from server
       * @returns {undefined}
       * @public
       * @memberof Meetings
       */

  }, {
    key: "syncMeetings",
    value: function syncMeetings() {
      var _this11 = this;

      return this.request.getActiveMeetings().then(function (locusArray) {
        var activeLocusUrl = [];

        if (locusArray !== null && locusArray !== void 0 && locusArray.loci && locusArray.loci.length > 0) {
          locusArray.loci.forEach(function (locus) {
            activeLocusUrl.push(locus.url);

            _this11.handleLocusEvent({
              locus: locus,
              locusUrl: locus.url
            });
          });
        }

        var meetingsCollection = _this11.meetingCollection.getAll();

        if ((0, _keys.default)(meetingsCollection).length > 0) {
          // Some time the mercury event is missed after mercury reconnect
          // if sync returns no locus then clear all the meetings
          for (var _i = 0, _Object$values = (0, _values.default)(meetingsCollection); _i < _Object$values.length; _i++) {
            var meeting = _Object$values[_i];

            if (!activeLocusUrl.includes(meeting.locusUrl)) {
              // destroy function also uploads logs
              _this11.destroy(meeting, _constants.MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);
            }
          }
        }
      });
    }
    /**
       * Get all scheduled meetings.
       * @param {object} options
       * @param {object} options.startDate - get meetings after this start date
       * @param {object} options.endDate - get meetings before this end date
       * @returns {Object} All scheduled meetings.
       * @memberof Meetings
       */

  }, {
    key: "getScheduledMeetings",
    value: function getScheduledMeetings() {
      return this.meetingCollection.getAll({
        scheduled: true
      });
    }
    /**
       * Get the logger instance for plugin-meetings
       * @returns {Logger}
       */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return _loggerProxy.default.get();
    }
  }]);
  return Meetings;
}(_webexCore.WebexPlugin);

exports.default = Meetings;
//# sourceMappingURL=index.js.map
