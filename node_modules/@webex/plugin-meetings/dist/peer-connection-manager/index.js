"use strict";

var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");

var _Symbol = require("@babel/runtime-corejs2/core-js/symbol");

var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");

var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _window = _interopRequireDefault(require("global/window"));

var _sdpTransform = _interopRequireDefault(require("sdp-transform"));

var _metrics = _interopRequireDefault(require("../metrics"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _config = _interopRequireDefault(require("../common/config"));

var _constants = require("../constants");

var _constants2 = _interopRequireDefault(require("../metrics/constants"));

var _config2 = require("../metrics/config");

var _media = _interopRequireDefault(require("../common/errors/media"));

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _webexErrors = require("../common/errors/webex-errors");

var _browserDetection = _interopRequireDefault(require("../common/browser-detection"));

var _util = _interopRequireDefault(require("./util"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof _Symbol !== "undefined" && o[_Symbol$iterator] || o["@@iterator"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _BrowserDetection = (0, _browserDetection.default)(),
    isBrowser = _BrowserDetection.isBrowser;
/**
 * @export
 * @public
 */


var pc = {};
/**
 * munges the bandwidth limit into the sdp
 * @param {String} sdpLines
 * @param {Number} index
 * @returns {String}
 */

var insertBandwidthLimit = function insertBandwidthLimit(sdpLines, index) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser
  var limit;
  var periodicKeyFrame = '';

  if (sdpLines[index].search(_constants.AUDIO) !== -1) {
    limit = _config.default.meetings.bandwidth.audio;
  } else {
    limit = _config.default.meetings.bandwidth.video;
    periodicKeyFrame = _constants.SDP.PERIODIC_KEYFRAME;
    sdpLines.splice(index + 2, 0, periodicKeyFrame);
  }

  sdpLines.splice(index + 1, 0, "".concat(_constants.SDP.B_LINE, ":").concat(limit));
  return sdpLines;
};
/**
 * needed for calliope max-fs
 * @param {String} sdp
 * @param {String} [level=QUALITY_LEVELS.HIGH] quality level for max-fs
 * @returns {String}
 */


var setMaxFs = function setMaxFs(sdp) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.QUALITY_LEVELS.HIGH;

  if (!_constants.MAX_FRAMESIZES[level]) {
    throw new _parameter.default("setMaxFs: unable to set max framesize, value for level \"".concat(level, "\" is not defined"));
  } // eslint-disable-next-line no-warning-comments
  // TODO convert with sdp parser, no munging


  var replaceSdp = sdp;
  var maxFsLine = "".concat(_constants.SDP.MAX_FS).concat(_constants.MAX_FRAMESIZES[level]);
  replaceSdp = replaceSdp.replace(/(\na=fmtp:(\d+).*profile-level-id=.*)/gi, "$1;".concat(maxFsLine));
  return replaceSdp;
};

var setStartBitrateOnRemoteSdp = function setStartBitrateOnRemoteSdp(sdp) {
  if (_config.default.meetings.bandwidth.startBitrate) {
    sdp = sdp.replace(/(\na=fmtp:(\d+).*profile-level-id=.*)/gi, "$1;x-google-start-bitrate=".concat(_config.default.meetings.bandwidth.startBitrate));
  }

  return sdp;
};
/**
 * checks that sdp has h264 codec in it
 * @param {String} sdp
 * @returns {boolean}
 */


var checkH264Support = function checkH264Support(sdp) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser to read rtp.codec
  var videoPresent = sdp.match(/\nm=video.*/g);
  var h264Present = sdp.match(/\na=rtpmap:\d+\sH264.*/g);

  if (videoPresent) {
    return !!h264Present;
  }

  return true;
};
/**
 * validates the sdp, checks port, candidates, and ice info
 * @param {String} sdp
 * @returns {String}
 */


var isSdpInvalid = function isSdpInvalid(sdp) {
  var parsedSdp = _sdpTransform.default.parse(sdp);

  var _iterator = _createForOfIteratorHelper(parsedSdp.media),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _mediaLine$candidates;

      var mediaLine = _step.value;

      if (!mediaLine.candidates || ((_mediaLine$candidates = mediaLine.candidates) === null || _mediaLine$candidates === void 0 ? void 0 : _mediaLine$candidates.length) === 0) {
        _loggerProxy.default.logger.error('PeerConnectionManager:index#isSdpInvalid --> iceCandidate: Ice candadate never completed');

        return 'iceCandidate: Ice gathering never completed';
      }

      if (_constants.SDP.BAD_MEDIA_PORTS.includes(mediaLine.port)) {
        _loggerProxy.default.logger.error('PeerConnectionManager:index#isSdpInvalid --> iceCandidate: Found invalid port number for the ice candidate');

        return 'iceCandidate: Found invalid port number for the ice candidate';
      }

      if (!mediaLine.icePwd || !mediaLine.iceUfrag) {
        _loggerProxy.default.logger.error('PeerConnectionManager:index#isSdpInvalid --> iceCandidate: ice ufrag and password not found');

        return 'iceCandidate: ice ufrag and password not found';
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return '';
};
/**
 * munges the bandwidth into the sdp
 * @param {String} sdp
 * @returns {String}
 */


var limitBandwidth = function limitBandwidth(sdp) {
  // TODO convert to sdp parser
  var offerSdp = sdp;
  var sdpLines = offerSdp.split(_constants.SDP.CARRIAGE_RETURN);

  for (var i = 0; i < sdpLines.length; i += 1) {
    if (sdpLines[i].search(_constants.SDP.M_LINE) !== -1) {
      sdpLines = insertBandwidthLimit(sdpLines, i);
    }
  }

  offerSdp = sdpLines.join(_constants.SDP.CARRIAGE_RETURN);
  return offerSdp;
};
/**
 * makes sure the screen pc sdp has content:slides for server
 * @param {RTCPeerConnection} screenPc
 * @returns {RTCPeerConnection}
 */


pc.setContentSlides = function (screenPc) {
  if (screenPc && screenPc.sdp) {
    screenPc.sdp += "".concat(_constants.SDP.A_CONTENT_SLIDES).concat(_constants.SDP.CARRIAGE_RETURN);
  }

  return screenPc;
};
/**
 * handles ice trickling and establishes ICE connection onto peer connection object
 * @param {Object} peerConnection
 * @param {Object} options
 * @param {String} options.remoteQualityLevel
 * @returns {Promise.RTCPeerConnection}
 */


pc.iceCandidate = function (peerConnection, _ref) {
  var remoteQualityLevel = _ref.remoteQualityLevel;
  return new _promise.default(function (resolve, reject) {
    var now = (0, _now.default)();

    var doneGatheringIceCandidate = function doneGatheringIceCandidate() {
      var miliseconds = (0, _parseInt2.default)(Math.abs((0, _now.default)() - now), 4);
      peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
      peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
      peerConnection.sdp = _util.default.convertCLineToIpv4(peerConnection.sdp);
      var invalidSdpPresent = isSdpInvalid(peerConnection.sdp);

      if (invalidSdpPresent) {
        _loggerProxy.default.logger.error('PeerConnectionManager:index#iceCandidate --> SDP not valid after waiting.');

        reject(new _webexErrors.InvalidSdpError(invalidSdpPresent));
      }

      _loggerProxy.default.logger.log("PeerConnectionManager:index#iceCandidate --> Time to gather ice candidate ".concat(miliseconds, " miliseconds"));

      resolve();
    }; // If ice has already been gathered


    if (peerConnection.iceGatheringState === _constants.COMPLETE) {
      doneGatheringIceCandidate();
    }

    peerConnection.onIceGatheringStateChange = function () {
      if (peerConnection.iceGatheringState === _constants.COMPLETE) {
        doneGatheringIceCandidate(peerConnection);
      }

      if (peerConnection.iceGatheringState === _constants.GATHERING) {
        _loggerProxy.default.logger.log('PeerConnectionManager:index#onIceGatheringStateChange --> Ice state changed to gathering');
      }
    };

    peerConnection.onicecandidate = function (evt) {
      if (evt.candidate === null) {
        doneGatheringIceCandidate(peerConnection);
      } else {
        var _evt$candidate, _evt$candidate2, _evt$candidate3, _evt$candidate4;

        _loggerProxy.default.logger.log("PeerConnectionManager:index#onicecandidate --> Candidate ".concat((_evt$candidate = evt.candidate) === null || _evt$candidate === void 0 ? void 0 : _evt$candidate.type, " ").concat((_evt$candidate2 = evt.candidate) === null || _evt$candidate2 === void 0 ? void 0 : _evt$candidate2.protocol, " ").concat((_evt$candidate3 = evt.candidate) === null || _evt$candidate3 === void 0 ? void 0 : _evt$candidate3.address, ":").concat((_evt$candidate4 = evt.candidate) === null || _evt$candidate4 === void 0 ? void 0 : _evt$candidate4.port));
      }
    };

    peerConnection.onicecandidateerror = function (event) {
      // we can often get ICE candidate errors (for example when failing to communicate with a TURN server)
      // they don't mean that the whole ICE connection will fail, so it's OK to ignore them
      _loggerProxy.default.logger.error('PeerConnectionManager:index#onicecandidateerror --> ignoring ice error:', event);
    };
  });
};
/**
 * swapping tracks
 * @param {Object} peerConnection
 * @param {Object} track
 * @returns {undefined}
 */


pc.replaceTrack = function (peerConnection, track) {
  try {
    var senders = peerConnection.getSenders();

    if (senders.length > 0) {
      senders.forEach(function (sender) {
        if (sender.track && sender.track.kind === track.kind) {
          sender.replaceTrack(track);
        }
      });
    }
  } catch (err) {
    _loggerProxy.default.logger.error("PeerConnectionManager:index#replaceTrack --> Error replacing track, ".concat(err));
  }
};
/**
 * adding streams to peerConnection
 * @param {Object} peerConnection
 * @param {Object} stream
 * @returns {undefined}
 */


pc.addStream = function (peerConnection, stream) {
  try {
    if (stream && !isBrowser('edge')) {
      var tracksPresent = peerConnection.getSenders && peerConnection.getSenders().find(function (sender) {
        return sender.track != null;
      });

      if (tracksPresent) {
        stream.getTracks().forEach(function (track) {
          pc.replaceTrack(peerConnection, track);
        });
        return;
      }

      stream.getTracks().forEach(function (track) {
        peerConnection.addTrack(track, stream);
      }); // // TODO : may come back disable addTracks for chrome they are moving back to addStream
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
      //   peerConnection.addStream(stream);
    } else if (isBrowser('edge')) {
      peerConnection.addStream(stream);
    }
  } catch (err) {
    _loggerProxy.default.logger.error("PeerConnectionManager:index#addStream --> Error adding stream, error: ".concat(_config2.error));
  }
};
/**
 * setting the remote description
 * @param {Object} peerConnection
 * @param {String} typeStr
 * @param {String} remoteSdp
 * @param {String} meetingId
 * @returns {undefined}
 */


pc.setRemoteSessionDetails = function (peerConnection, typeStr, remoteSdp, meetingId) {
  _loggerProxy.default.logger.log("PeerConnectionManager:index#setRemoteSessionDetails --> Setting the remote description type: ".concat(typeStr, "State: ").concat(peerConnection.signalingState));

  var sdp = remoteSdp; // making sure that the remoteDescription is only set when there is a answer for offer
  // or there is a offer from the server

  if (!sdp) {
    _metrics.default.postEvent({
      event: _config2.eventType.REMOTE_SDP_RECEIVED,
      meetingId: meetingId,
      data: {
        canProceed: false,
        errors: [_metrics.default.generateErrorPayload(2001, true, _config2.error.name.MEDIA_ENGINE, 'missing remoteSdp')]
      }
    });
  }

  if (peerConnection.signalingState === _constants.SDP.HAVE_LOCAL_OFFER || peerConnection.signalingState === _constants.SDP.STABLE && typeStr === _constants.SDP.OFFER) {
    sdp = setStartBitrateOnRemoteSdp(sdp);

    if (!peerConnection.enableExtmap) {
      sdp = sdp.replace(/\na=extmap.*/g, '');
    } // remove any xtls candidates


    sdp = sdp.replace(/^a=candidate:.*xTLS.*\r\n/gim, '');
    return peerConnection.setRemoteDescription(new _window.default.RTCSessionDescription({
      type: typeStr,
      sdp: sdp
    })).then(function () {
      if (peerConnection.signalingState === _constants.SDP.STABLE) {
        _metrics.default.postEvent({
          event: _config2.eventType.REMOTE_SDP_RECEIVED,
          meetingId: meetingId
        });
      }
    }).catch(function (error) {
      _loggerProxy.default.logger.error("Peer-connection-manager:index#setRemoteDescription --> ".concat(error, " missing remotesdp"));

      var metricName = _constants2.default.PEERCONNECTION_FAILURE;
      var data = {
        correlation_id: meetingId,
        reason: error.message,
        stack: error.stack
      };
      var metadata = {
        type: error.name
      };

      _metrics.default.sendBehavioralMetric(metricName, data, metadata);

      return _metrics.default.postEvent({
        event: _config2.eventType.REMOTE_SDP_RECEIVED,
        meetingId: meetingId,
        data: {
          canProceed: false,
          errors: [_metrics.default.generateErrorPayload(2001, true, error.name.MEDIA_ENGINE, 'missing remoteSdp')]
        }
      });
    });
  }

  return _promise.default.reject(new _media.default('PeerConnection in wrong state'));
};
/**
 * create offer with a valid paramater
 * @param {Object} peerConnection
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @param {string} meetingProperties.enableRtx
 * @param {string} meetingProperties.enableExtmap
 * @returns {RTCPeerConnection}
 */


pc.createOffer = function (peerConnection, _ref2) {
  var meetingId = _ref2.meetingId,
      remoteQualityLevel = _ref2.remoteQualityLevel,
      enableRtx = _ref2.enableRtx,
      enableExtmap = _ref2.enableExtmap;

  _loggerProxy.default.logger.log('PeerConnectionManager:index#createOffer --> creating a new offer'); // saving the extMap State to use in setRemoteDescription


  peerConnection.enableExtmap = enableExtmap;
  return peerConnection.createOffer().then(function (description) {
    // bug https://bugs.chromium.org/p/chromium/issues/detail?id=1020642
    // chrome currently generates RTX line irrespective of weither the server side supports it
    // we are removing apt as well because its associated with rtx line
    if (!enableRtx) {
      description.sdp = description.sdp.replace(/\r\na=rtpmap:\d+ rtx\/\d+/g, '');
      description.sdp = description.sdp.replace(/\r\na=fmtp:\d+ apt=\d+/g, '');
    }

    return peerConnection.setLocalDescription(description);
  }).then(function () {
    return pc.iceCandidate(peerConnection, {
      remoteQualityLevel: remoteQualityLevel
    });
  }).then(function () {
    if (!checkH264Support(peerConnection.sdp)) {
      throw new _media.default('openH264 is downloading please Wait. Upload logs if not working on second try');
    }

    if (!enableExtmap) {
      peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');
    }

    pc.setContentSlides(peerConnection);

    _metrics.default.postEvent({
      event: _config2.eventType.LOCAL_SDP_GENERATED,
      meetingId: meetingId
    });

    return peerConnection;
  }).catch(function (error) {
    _loggerProxy.default.logger.error("Peer-connection-manager:index#createOffer --> ".concat(error));

    if (error instanceof _webexErrors.InvalidSdpError) {
      _metrics.default.sendBehavioralMetric(_constants2.default.INVALID_ICE_CANDIDATE, {
        correlation_id: meetingId,
        code: error.code,
        reason: error.message
      });
    } else {
      var metricName = _constants2.default.PEERCONNECTION_FAILURE;
      var data = {
        correlation_id: meetingId,
        reason: error.message,
        stack: error.stack
      };
      var metadata = {
        type: error.name
      };

      _metrics.default.sendBehavioralMetric(metricName, data, metadata);
    }

    _metrics.default.postEvent({
      event: _config2.eventType.LOCAL_SDP_GENERATED,
      meetingId: meetingId,
      data: {
        canProceed: false,
        errors: [_metrics.default.generateErrorPayload(2001, true, error.name.MEDIA_ENGINE)]
      }
    });

    pc.close(peerConnection);
    throw error;
  });
};
/**
 * rollBack local description in peerconnection
 * @param {Object} peerConnection
 * @returns {Promise.RTCPeerConnection}
 */


pc.rollBackLocalDescription = function (peerConnection) {
  return peerConnection.setLocalDescription(new RTCSessionDescription({
    type: _constants.SDP.ROLLBACK
  })).then(function () {
    return peerConnection;
  }).catch(function (err) {
    _loggerProxy.default.logger.error("Peer-connection-manager:index#setLocalDescription --> ".concat(err, " "));

    return _promise.default.error(err);
  });
};
/**
 * @param {Object} params {
 * @param {Boolean} params.offerToReceiveAudio
 * @param {Boolean} params.offerToReceiveVideo
 * @param {string} params.offerSdp
 * @param {MediaStream} params.stream
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {Promise.<Array>} [MediaSDP, ScreenSDP]
 */


pc.updatePeerConnection = function (params, _ref3) {
  var meetingId = _ref3.meetingId,
      remoteQualityLevel = _ref3.remoteQualityLevel;

  _loggerProxy.default.logger.log("PeerConnectionManager:index#updatePeerConnection --> updating the peerConnection with params: ".concat(params));

  var peerConnection = params.peerConnection,
      offerSdp = params.offerSdp;
  return pc.createAnswer({
    peerConnection: peerConnection,
    offerSdp: offerSdp[0]
  }, {
    meetingId: meetingId,
    remoteQualityLevel: remoteQualityLevel
  }).then(function (peerconnection) {
    // The content slides should also be set when we are sending inactive
    pc.setContentSlides(peerconnection);
    return _promise.default.resolve([peerconnection.sdp]);
  });
};
/**
 * @param {Object} params
 * @param {Object} params.peerConnection
 * @param {Object} params.sdpConstraints
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {RTCPeerConnection} peerConnection
 */


pc.createAnswer = function (params, _ref4) {
  var meetingId = _ref4.meetingId,
      remoteQualityLevel = _ref4.remoteQualityLevel;
  var peerConnection = params.peerConnection; // TODO: Some times to many mercury event comes at the same time
  // Need to maintain state of peerconnection

  if (peerConnection.signalingState === _constants.SDP.HAVE_REMOTE_OFFER) {
    return _promise.default.resolve(peerConnection);
  }

  return pc.setRemoteSessionDetails(peerConnection, _constants.OFFER, params.offerSdp, meetingId).then(function () {
    return peerConnection.createAnswer(params.sdpConstraints);
  }).then(function (answer) {
    return peerConnection.setLocalDescription(answer);
  }).then(function () {
    return pc.iceCandidate(peerConnection, {
      remoteQualityLevel: remoteQualityLevel
    });
  }).then(function () {
    peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
    peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
    peerConnection.sdp = _util.default.convertCLineToIpv4(peerConnection.sdp);

    if (!checkH264Support(peerConnection.sdp)) {
      throw new _media.default('openH264 is downloading please Wait. Upload logs if not working on second try');
    }

    return peerConnection;
  }).catch(function (error) {
    if (error instanceof _webexErrors.InvalidSdpError) {
      _metrics.default.sendBehavioralMetric(_constants2.default.INVALID_ICE_CANDIDATE, {
        correlation_id: meetingId
      });
    } else {
      var metricName = _constants2.default.PEERCONNECTION_FAILURE;
      var data = {
        correlation_id: meetingId,
        reason: error.message,
        stack: error.stack
      };
      var metadata = {
        type: error.name
      };

      _metrics.default.sendBehavioralMetric(metricName, data, metadata);
    }

    _loggerProxy.default.logger.error("PeerConnectionManager:index#setRemoteSessionDetails --> Error creating remote session, error: ".concat(error));
  });
};
/**
 * shut down the peer connection
 * @param {Object} peerConnection
 * @returns {undefined}
 */


pc.close = function (peerConnection) {
  // peerConnection.close() fails on firefox on network changes and gives a Dom exception
  // To avoid this we have added a try catch block.
  // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1274407 for more information
  _loggerProxy.default.logger.log('PeerConnectionManager:index#close --> pc: close() -> attempting to close the peer connection');

  if (peerConnection && peerConnection.connectionState === _constants.PEER_CONNECTION_STATE.CLOSED) {
    _loggerProxy.default.logger.log('PeerConnectionManager:index#close --> pc: close() -> connection already closed');

    return _promise.default.resolve();
  }

  _loggerProxy.default.logger.log('PeerConnectionManager:index#close --> pc: close() -> closing the mediaPeerConnection');

  return _promise.default.resolve().then(function () {
    if (peerConnection && peerConnection.close) {
      peerConnection.close();
    }
  });
};

pc.setPeerConnectionEvents = function (meeting) {
  // In case ICE fail
  var peerConnection = meeting.mediaProperties.peerConnection;

  var connectionFailed = function connectionFailed() {
    if (meeting.reconnectionManager.iceState.resolve) {
      // DISCONNECTED state triggers first then it goes to FAILED STATE
      // sometimes the failed state can happen before 10 seconds (Which is the timer for the reconnect for ice disconnect)
      meeting.reconnectionManager.iceState.resolve();
    }

    meeting.reconnect({
      networkDisconnect: true
    });

    _metrics.default.postEvent({
      event: _config2.eventType.ICE_END,
      meeting: meeting,
      data: {
        canProceed: false,
        errors: [_metrics.default.generateErrorPayload(2004, false, _config2.error.name.MEDIA_ENGINE)]
      }
    });

    meeting.uploadLogs({
      file: 'peer-connection-manager/index',
      function: 'connectionFailed'
    });

    _metrics.default.sendBehavioralMetric(_constants2.default.CONNECTION_FAILURE, {
      correlation_id: meeting.correlationId,
      locus_id: meeting.locusId
    });
  };

  peerConnection.oniceconnectionstatechange = function () {
    _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CHANGE.');

    switch (peerConnection.iceConnectionState) {
      case _constants.ICE_STATE.CHECKING:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CHECKING.');

        _metrics.default.postEvent({
          event: _config2.eventType.ICE_START,
          meeting: meeting
        });

        break;

      case _constants.ICE_STATE.COMPLETED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE COMPLETED.');

        break;

      case _constants.ICE_STATE.CONNECTED:
        // Ice connection state goes to connected when both client and server sends STUN packets and
        // Established connected between them. Firefox does not trigger COMPLETED and only trigger CONNECTED
        _metrics.default.postEvent({
          event: _config2.eventType.ICE_END,
          meeting: meeting
        });

        _metrics.default.sendBehavioralMetric(_constants2.default.CONNECTION_SUCCESS, {
          correlation_id: meeting.correlationId,
          locus_id: meeting.locusId
        });

        meeting.setNetworkStatus(_constants.NETWORK_STATUS.CONNECTED);
        meeting.reconnectionManager.iceReconnected();

        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CONNECTED.');

        break;

      case _constants.ICE_STATE.CLOSED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CLOSED.');

        break;

      case _constants.ICE_STATE.DISCONNECTED:
        meeting.setNetworkStatus(_constants.NETWORK_STATUS.DISCONNECTED);
        meeting.reconnectionManager.waitForIceReconnect().catch(function () {
          _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE DISCONNECTED. Automatic Reconnection Timed Out.');

          connectionFailed();
        });

        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE DISCONNECTED.');

        break;

      case _constants.ICE_STATE.FAILED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE FAILED.'); // notify of ice failure
        // Ice failure is the only indicator currently for identifying the actual connection drop
        // Firefox takes sometime 10-15 seconds to go to failed state


        connectionFailed();
        break;

      default:
        break;
    }
  };

  peerConnection.onconnectionstatechange = function () {
    _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CHANGE.');

    switch (peerConnection.connectionState) {
      case _constants.CONNECTION_STATE.NEW:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE NEW.');

        break;

      case _constants.CONNECTION_STATE.CONNECTING:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CONNECTING.');

        break;

      case _constants.CONNECTION_STATE.CONNECTED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CONNECTED.');

        break;

      case _constants.CONNECTION_STATE.CLOSED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CLOSED.');

        break;

      case _constants.CONNECTION_STATE.DISCONNECTED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE DISCONNECTED.');

        break;

      case _constants.CONNECTION_STATE.FAILED:
        _loggerProxy.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE FAILED.'); // Special case happens only on chrome where there is no ICE FAILED event
        // only CONNECTION FAILED event gets triggered


        connectionFailed();
        break;

      default:
        break;
    }
  };
};

var _default = pc;
exports.default = _default;
//# sourceMappingURL=index.js.map
