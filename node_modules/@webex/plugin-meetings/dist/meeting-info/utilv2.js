"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _url = _interopRequireDefault(require("url"));

var _common = require("@webex/common");

var _constants = require("../constants");

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var MeetingInfoUtil = {};

MeetingInfoUtil.getParsedUrl = function (link) {
  try {
    var parsedUrl = _url.default.parse(link);

    if (!parsedUrl) {
      return false;
    } // hack for links such as <company>.webex.com/meet/<user> without a protocol


    if (!parsedUrl.protocol) {
      parsedUrl = _url.default.parse("".concat(_constants.HTTPS_PROTOCOL).concat(link));
    }

    return parsedUrl;
  } catch (error) {
    _loggerProxy.default.logger.warn("Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ".concat(error));

    return null;
  }
};
/**
 * Helper function to check if a string matches a known meeting link pattern
 * @param {String} value  string to parse and see if it matches a meeting link
 * @returns {Boolean}
 */


MeetingInfoUtil.isMeetingLink = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);
  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);
  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes("/".concat(_constants.MEET)) || parsedUrl.pathname.includes("/".concat(_constants.MEET_M)) || parsedUrl.pathname.includes("/".concat(_constants.JOIN)));
  return hostNameBool && pathNameBool;
};

MeetingInfoUtil.isConversationUrl = function (value, webex) {
  var clusterId = webex.internal.services.getClusterId(value);

  if (clusterId) {
    return clusterId.endsWith(_constants.CONVERSATION_SERVICE);
  }

  return false;
};

MeetingInfoUtil.isSipUri = function (sipString) {
  // TODO: lets remove regex from this equation and user URI matchers and such
  // have not found a great sip uri parser library as of now
  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);

  return sipUri;
};

MeetingInfoUtil.isPhoneNumber = function (phoneNumber) {
  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);

  return isValidNumber;
};

MeetingInfoUtil.getHydraId = function (destination) {
  var _deconstructHydraId = (0, _common.deconstructHydraId)(destination),
      type = _deconstructHydraId.type,
      id = _deconstructHydraId.id,
      cluster = _deconstructHydraId.cluster;

  if (id && _constants.UUID_REG.test(id)) {
    if (type === _constants._ROOM_) {
      return {
        room: true,
        destination: id,
        cluster: cluster
      };
    }

    if (type === _constants._PEOPLE_) {
      return {
        people: true,
        destination: id,
        cluster: cluster
      };
    }

    return {};
  }

  return {};
};

MeetingInfoUtil.getSipUriFromHydraPersonId = function (destination, webex) {
  return webex.people.get(destination).then(function (res) {
    if (res.emails && res.emails.length) {
      return res.emails[0];
    }

    throw new _parameter.default('Hydra Id Lookup was an invalid hydra person id.');
  }).catch(function (err) {
    _loggerProxy.default.logger.error("Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ".concat(err, " "));

    throw err;
  });
};

MeetingInfoUtil.getDestinationType = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(from) {
    var type, webex, destination, _options, res, _res$items$, orgId, userId, options, hydraId, conversationUrl;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            type = from.type, webex = from.webex;
            destination = from.destination;

            if (!(type === _constants._PERSONAL_ROOM_)) {
              _context.next = 15;
              break;
            }

            if (destination) {
              _context.next = 7;
              break;
            }

            // if we are not getting anything in desination we fetch org and user ids from webex instance
            destination = {
              userId: webex.internal.device.userId,
              orgId: webex.internal.device.orgId
            };
            _context.next = 15;
            break;

          case 7:
            _options = _constants.VALID_EMAIL_ADDRESS.test(destination) ? {
              email: destination
            } : {
              id: destination
            }; // we are assuming userId as default

            _context.next = 10;
            return webex.people.list(_options);

          case 10:
            res = _context.sent;
            _res$items$ = res.items[0], orgId = _res$items$.orgId, userId = _res$items$.id;
            userId = (0, _common.deconstructHydraId)(userId).id;
            orgId = (0, _common.deconstructHydraId)(orgId).id;
            destination = {
              userId: userId,
              orgId: orgId
            };

          case 15:
            if (!type) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", {
              destination: destination,
              type: type
            });

          case 17:
            options = {};
            hydraId = MeetingInfoUtil.getHydraId(destination);

            if (!MeetingInfoUtil.isMeetingLink(destination)) {
              _context.next = 25;
              break;
            }

            _loggerProxy.default.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');

            options.type = _constants._MEETING_LINK_;
            options.destination = destination;
            _context.next = 62;
            break;

          case 25:
            if (!MeetingInfoUtil.isSipUri(destination)) {
              _context.next = 30;
              break;
            }

            options.type = _constants._SIP_URI_;
            options.destination = destination;
            _context.next = 62;
            break;

          case 30:
            if (!MeetingInfoUtil.isPhoneNumber(destination)) {
              _context.next = 35;
              break;
            }

            options.type = _constants._SIP_URI_;
            options.destination = destination;
            _context.next = 62;
            break;

          case 35:
            if (!MeetingInfoUtil.isConversationUrl(destination, webex)) {
              _context.next = 40;
              break;
            }

            options.type = _constants._CONVERSATION_URL_;
            options.destination = destination;
            _context.next = 62;
            break;

          case 40:
            if (!hydraId.people) {
              _context.next = 45;
              break;
            }

            options.type = _constants._SIP_URI_;
            return _context.abrupt("return", MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then(function (res) {
              options.destination = res; // Since hydra person ids require a unique case in which they are
              // entirely converted to a SIP URI, we need to set a flag for detecting
              // this type of destination.

              options.wasHydraPerson = true;
              return _promise.default.resolve(options);
            }));

          case 45:
            if (!hydraId.room) {
              _context.next = 60;
              break;
            }

            options.type = _constants._CONVERSATION_URL_;
            _context.prev = 47;
            _context.next = 50;
            return webex.internal.services.waitForCatalog('postauth');

          case 50:
            conversationUrl = webex.internal.conversation.getUrlFromClusterId({
              cluster: hydraId.cluster,
              id: hydraId.destination
            });
            options.destination = conversationUrl;
            _context.next = 58;
            break;

          case 54:
            _context.prev = 54;
            _context.t0 = _context["catch"](47);

            _loggerProxy.default.logger.error("Meeting-info:util#getDestinationType --> ".concat(_context.t0));

            throw _context.t0;

          case 58:
            _context.next = 62;
            break;

          case 60:
            _loggerProxy.default.logger.warn('Meeting-info:util#getDestinationType --> (\'MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');

            throw new _parameter.default('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');

          case 62:
            return _context.abrupt("return", _promise.default.resolve(options));

          case 63:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[47, 54]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Helper function to build up a correct locus url depending on the value passed
 * @param {Object} options type and value to fetch meeting info
 * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} options.destination ?? value.value
 * @returns {Object} returns an object with {resource, method}
 */


MeetingInfoUtil.getRequestBody = function (options) {
  var _destination$info, _destination$info2;

  var type = options.type,
      destination = options.destination,
      password = options.password,
      captchaInfo = options.captchaInfo;
  var body = {
    supportHostKey: true,
    supportCountryList: true
  };

  switch (type) {
    case _constants._SIP_URI_:
      body.sipUrl = destination;
      break;

    case _constants._PERSONAL_ROOM_:
      body.userId = destination.userId;
      body.orgId = destination.orgId;
      break;

    case _constants._MEETING_ID_:
      body.meetingKey = destination;
      break;

    case _constants._CONVERSATION_URL_:
      body.conversationUrl = destination;
      break;

    case _constants._LOCUS_ID_:
      // use meetingID for the completer meeting info for the already started meeting
      if ((_destination$info = destination.info) !== null && _destination$info !== void 0 && _destination$info.webExMeetingId) {
        body.meetingKey = destination.info.webExMeetingId;
      } else if ((_destination$info2 = destination.info) !== null && _destination$info2 !== void 0 && _destination$info2.sipUri) {
        body.sipUrl = destination.info.sipUri;
      }

      break;

    case _constants._MEETING_LINK_:
      body.meetingUrl = destination;
      break;

    case _constants._MEETING_UUID_:
      {
        body.meetingUUID = destination;
        break;
      }

    default:
  }

  if (password) {
    body.password = password;
  }

  if (captchaInfo) {
    body.captchaID = captchaInfo.id;
    body.captchaVerifyCode = captchaInfo.code;
  }

  return body;
};
/**
 * Helper function to parse the webex site/host from a URI string.
 * @param {String} uri string (e.g. '10019857020@convergedats.webex.com')
 * @returns {String} the site/host part of the URI string (e.g. 'convergedats.webex.com')
 */


MeetingInfoUtil.getWebexSite = function (uri) {
  var _uri$match;

  var exceptedDomains = ['meet.webex.com', 'meetup.webex.com', 'ciscospark.com'];
  var site = uri === null || uri === void 0 ? void 0 : (_uri$match = uri.match(/.+@([^.]+\.[^.]+\.[^.]+)$/)) === null || _uri$match === void 0 ? void 0 : _uri$match[1];
  return exceptedDomains.includes(site) ? null : site;
};
/**
 * Helper function to return the direct URI for fetching meeting info (to avoid a redirect).
 * @param {Object} options type and value to fetch meeting info
 * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} options.destination ?? value.value
 * @returns {String} returns a URI string or null of there is no direct URI
 */


MeetingInfoUtil.getDirectMeetingInfoURI = function (options) {
  var _destination$info3;

  var type = options.type,
      destination = options.destination;
  var preferredWebexSite = null;

  switch (type) {
    case _constants._SIP_URI_:
      preferredWebexSite = MeetingInfoUtil.getWebexSite(destination);
      break;

    case _constants._LOCUS_ID_:
      preferredWebexSite = (_destination$info3 = destination.info) === null || _destination$info3 === void 0 ? void 0 : _destination$info3.webExSite;
      break;

    default:
  }

  return preferredWebexSite ? "https://".concat(preferredWebexSite, "/wbxappapi/v1/meetingInfo") : null;
};

var _default = MeetingInfoUtil;
exports.default = _default;
//# sourceMappingURL=utilv2.js.map
