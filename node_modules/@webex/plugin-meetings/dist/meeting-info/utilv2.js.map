{"version":3,"names":["MeetingInfoUtil","getParsedUrl","link","parsedUrl","url","parse","protocol","HTTPS_PROTOCOL","error","LoggerProxy","logger","warn","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","isConversationUrl","webex","clusterId","internal","services","getClusterId","endsWith","CONVERSATION_SERVICE","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","getHydraId","destination","deconstructHydraId","type","id","cluster","UUID_REG","_ROOM_","room","_PEOPLE_","people","getSipUriFromHydraPersonId","get","then","res","emails","length","ParameterError","catch","err","getDestinationType","from","_PERSONAL_ROOM_","userId","device","orgId","options","VALID_EMAIL_ADDRESS","email","list","items","hydraId","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","wasHydraPerson","resolve","waitForCatalog","conversationUrl","conversation","getUrlFromClusterId","getRequestBody","password","captchaInfo","body","supportHostKey","supportCountryList","sipUrl","_MEETING_ID_","meetingKey","_LOCUS_ID_","info","webExMeetingId","meetingUrl","_MEETING_UUID_","meetingUUID","captchaID","captchaVerifyCode","code","getWebexSite","uri","exceptedDomains","site","match","getDirectMeetingInfoURI","preferredWebexSite","webExSite"],"sources":["utilv2.js"],"sourcesContent":["import url from 'url';\n\nimport {\n  deconstructHydraId\n} from '@webex/common';\n\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  _MEETING_UUID_,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  UUID_REG,\n  VALID_EMAIL_ADDRESS\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  }\n  catch (error) {\n    LoggerProxy.logger.warn(`Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ${error}`);\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const {type, id, cluster} = deconstructHydraId(destination);\n\n  if (id && UUID_REG.test(id)) {\n    if (type === _ROOM_) {\n      return {room: true, destination: id, cluster};\n    }\n    if (type === _PEOPLE_) {\n      return {people: true, destination: id, cluster};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) => webex.people.get(destination).then((res) => {\n  if (res.emails && res.emails.length) {\n    return res.emails[0];\n  }\n  throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n}).catch((err) => {\n  LoggerProxy.logger.error(`Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ${err} `);\n  throw err;\n});\n\n\nMeetingInfoUtil.getDestinationType = async (from) => {\n  const {type, webex} = from;\n  let {destination} = from;\n\n  if (type === _PERSONAL_ROOM_) { // this case checks if your type is personal room\n    if (!destination) { // if we are not getting anything in desination we fetch org and user ids from webex instance\n      destination = {\n        userId: webex.internal.device.userId,\n        orgId: webex.internal.device.orgId\n      };\n    }\n    else {\n      const options = VALID_EMAIL_ADDRESS.test(destination) ? {email: destination} : {id: destination};// we are assuming userId as default\n      const res = await webex.people.list(options);\n\n      let {orgId, id: userId} = res.items[0];\n\n      userId = deconstructHydraId(userId).id;\n      orgId = deconstructHydraId(orgId).id;\n      destination = {userId, orgId};\n    }\n  }\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    LoggerProxy.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');\n\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  }\n  else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      // Since hydra person ids require a unique case in which they are\n      // entirely converted to a SIP URI, we need to set a flag for detecting\n      // this type of destination.\n      options.wasHydraPerson = true;\n\n      return Promise.resolve(options);\n    });\n  }\n  else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    try {\n      await webex.internal.services.waitForCatalog('postauth');\n\n      const conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n        cluster: hydraId.cluster,\n        id: hydraId.destination\n      });\n\n      options.destination = conversationUrl;\n    }\n    catch (e) {\n      LoggerProxy.logger.error(`Meeting-info:util#getDestinationType --> ${e}`);\n      throw (e);\n    }\n  }\n  else {\n    LoggerProxy.logger.warn('Meeting-info:util#getDestinationType --> (\\'MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n    throw new ParameterError('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getRequestBody = (options) => {\n  const {\n    type, destination, password, captchaInfo\n  } = options;\n  const body = {\n    supportHostKey: true,\n    supportCountryList: true,\n  };\n\n  switch (type) {\n    case _SIP_URI_:\n      body.sipUrl = destination;\n      break;\n    case _PERSONAL_ROOM_:\n      body.userId = destination.userId;\n      body.orgId = destination.orgId;\n      break;\n    case _MEETING_ID_:\n      body.meetingKey = destination;\n      break;\n    case _CONVERSATION_URL_:\n      body.conversationUrl = destination;\n      break;\n    case _LOCUS_ID_:\n      // use meetingID for the completer meeting info for the already started meeting\n      if (destination.info?.webExMeetingId) {\n        body.meetingKey = destination.info.webExMeetingId;\n      }\n      else if (destination.info?.sipUri) {\n        body.sipUrl = destination.info.sipUri;\n      }\n      break;\n    case _MEETING_LINK_:\n      body.meetingUrl = destination;\n      break;\n    case _MEETING_UUID_: {\n      body.meetingUUID = destination;\n      break;\n    }\n    default:\n  }\n\n  if (password) {\n    body.password = password;\n  }\n\n  if (captchaInfo) {\n    body.captchaID = captchaInfo.id;\n    body.captchaVerifyCode = captchaInfo.code;\n  }\n\n  return body;\n};\n\n/**\n * Helper function to parse the webex site/host from a URI string.\n * @param {String} uri string (e.g. '10019857020@convergedats.webex.com')\n * @returns {String} the site/host part of the URI string (e.g. 'convergedats.webex.com')\n */\nMeetingInfoUtil.getWebexSite = (uri) => {\n  const exceptedDomains = ['meet.webex.com', 'meetup.webex.com', 'ciscospark.com'];\n  const site = uri?.match(/.+@([^.]+\\.[^.]+\\.[^.]+)$/)?.[1];\n\n  return exceptedDomains.includes(site) ? null : site;\n};\n\n/**\n * Helper function to return the direct URI for fetching meeting info (to avoid a redirect).\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {String} returns a URI string or null of there is no direct URI\n */\nMeetingInfoUtil.getDirectMeetingInfoURI = (options) => {\n  const {\n    type, destination\n  } = options;\n\n  let preferredWebexSite = null;\n\n  switch (type) {\n    case _SIP_URI_:\n      preferredWebexSite = MeetingInfoUtil.getWebexSite(destination);\n      break;\n    case _LOCUS_ID_:\n      preferredWebexSite = destination.info?.webExSite;\n      break;\n    default:\n  }\n\n  return preferredWebexSite ? `https://${preferredWebexSite}/wbxappapi/v1/meetingInfo` : null;\n};\n\nexport default MeetingInfoUtil;\n"],"mappings":"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"}