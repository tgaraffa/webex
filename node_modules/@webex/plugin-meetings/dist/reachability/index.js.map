{"version":3,"names":["DEFAULT_TIMEOUT","VIDEO_MESH_TIMEOUT","Reachability","webex","reachabilityRequest","ReachabilityRequest","clusterLatencyResults","setup","window","localStorage","removeItem","REACHABILITY","LoggerProxy","logger","error","getClusters","clusters","performReachabilityCheck","results","setItem","log","cluster","iceServers","udp","tcp","map","url","username","credential","urls","iceCandidatePoolSize","iceTransportPolicy","key","config","peerConnection","RTCPeerConnection","peerConnectionError","startTime","begin","clusterList","buildPeerConnectionConfig","createPeerConnection","createOffer","offerToReceiveAudio","description","setLocalDescription","iceGatheringState","isVideoMesh","catch","iceGatheringStateError","all","then","parseIceResultsToReachabilityResults","reachabilityLatencyResults","logUnreachableClusters","unreachableList","forEach","unreachable","reachable","push","onicegatheringstatechange","COMPLETE","ICE_GATHERING_STATE","iceConnectionState","elapsed","getElapsedTime","setLatencyAndClose","onicecandidate","e","SERVER_REFLEXIVE","candidate","String","type","toLowerCase","timeout","ELAPSED","resolve","peerConnectionProxy","Proxy","get","target","property","targetMember","bind","set","value","clusterId","Reflect","handleIceGatheringStateChange","handleOnIceCandidate","setTimeout","CLOSED","CONNECTION_STATE","connectionState","list","getUnreachablClusters","iceResults","reachabilityMap","latencyResult","latencyInMilliseconds","toString","length","getLocalSDPForClusters","localSDPData","REACHABLE","UNREACHABLE","resultKey","intialState","close"],"sources":["index.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint-disable class-methods-use-this */\n/* globals window */\nimport _ from 'lodash';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  ICE_GATHERING_STATE,\n  CONNECTION_STATE,\n  REACHABILITY\n} from '../constants';\n\nimport ReachabilityRequest from './request';\n\nconst DEFAULT_TIMEOUT = 3000;\nconst VIDEO_MESH_TIMEOUT = 1000;\n\n/**\n * @class Reachability\n * @export\n */\nexport default class Reachability {\n  /**\n   * Creates an instance of Reachability.\n   * @param {object} webex\n   * @memberof Reachability\n   */\n  constructor(webex) {\n    this.webex = webex;\n\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n    this.reachabilityRequest = new ReachabilityRequest(this.webex);\n\n    /**\n     * internal object of clusters latency results\n     * @instance\n     * @type {object}\n     * @private\n     * @memberof Reachability\n     */\n    this.clusterLatencyResults = {};\n  }\n\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @async\n   * @memberof Reachability\n   */\n  async gatherReachability() {\n    this.setup();\n\n    // Remove stored reachability results to ensure no stale data\n    if (window?.localStorage?.removeItem) {\n      window.localStorage.removeItem(REACHABILITY.localStorage);\n    }\n    else {\n      LoggerProxy.logger.error('Reachability:index#gatherReachability --> Error in accessing LocalStorage.');\n\n      return {};\n    }\n\n    // Fetch clusters and measure latency\n    try {\n      const clusters = await this.reachabilityRequest.getClusters();\n\n      // Perform Reachability Check\n      const results = await this.performReachabilityCheck(clusters);\n\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(results));\n\n      LoggerProxy.logger.log('Reachability:index#gatherReachability --> Reachability checks completed');\n\n      return results;\n    }\n    catch (getClusterError) {\n      LoggerProxy.logger.error(`Reachability:index#gatherReachability --> Error in calling getClusters(): ${getClusterError}`);\n\n      return {};\n    }\n  }\n\n\n  /**\n   * Generate peerConnection config settings\n   * @param {object} cluster\n   * @returns {object} peerConnectionConfig\n   * @private\n   * @memberof Reachability\n   */\n  buildPeerConnectionConfig(cluster) {\n    const iceServers = _.uniq([\n      ...cluster.udp,\n      ...cluster.tcp\n    ]).map((url) => ({\n      username: '',\n      credential: '',\n      urls: [url]\n    }));\n\n    return {\n      iceServers: [\n        ...iceServers\n      ],\n      iceCandidatePoolSize: '0',\n      iceTransportPolicy: 'all'\n    };\n  }\n\n\n  /**\n   * Creates an RTCPeerConnection\n   * @param {object} cluster\n   * @returns {RTCPeerConnection} peerConnection\n   * @private\n   * @memberof Reachability\n   */\n  createPeerConnection(cluster) {\n    const {key, config} = cluster;\n\n    try {\n      const peerConnection = new window.RTCPeerConnection(config);\n\n      peerConnection.key = key;\n\n      return peerConnection;\n    }\n    catch (peerConnectionError) {\n      LoggerProxy.logger.log(`Reachability:index#createPeerConnection --> Error creating peerConnection: ${peerConnectionError}`);\n\n      return null;\n    }\n  }\n\n\n  /**\n   * Gets total elapsed time\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {Number} Milliseconds\n   * @private\n   * @memberof Reachability\n   */\n  getElapsedTime(peerConnection) {\n    const startTime = peerConnection.begin;\n\n    delete peerConnection.begin;\n\n    return Date.now() - startTime;\n  }\n\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {Promise} Reachability latency results\n   * @private\n   * @memberof Reachability\n   */\n  getLocalSDPForClusters(clusterList) {\n    let clusters = [...Object.keys(clusterList)];\n\n    clusters = clusters.map(async (key) => {\n      const cluster = clusterList[key];\n      const config = this.buildPeerConnectionConfig(cluster);\n      const peerConnection = this.createPeerConnection({key, config});\n      const description = await peerConnection.createOffer({offerToReceiveAudio: true});\n\n      peerConnection.begin = Date.now();\n      peerConnection.setLocalDescription(description);\n\n      return this.iceGatheringState(peerConnection, cluster.isVideoMesh ? VIDEO_MESH_TIMEOUT : DEFAULT_TIMEOUT)\n        .catch((iceGatheringStateError) => {\n          LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : ${iceGatheringStateError}`);\n        });\n    });\n\n    return Promise.all(clusters)\n      .then(this.parseIceResultsToReachabilityResults)\n      .then((reachabilityLatencyResults) => {\n        this.logUnreachableClusters();\n\n        // return results\n        return reachabilityLatencyResults;\n      });\n  }\n\n\n  /**\n   * Get list of all unreachable clusters\n   * @returns {array} Unreachable clusters\n   * @private\n   * @memberof Reachability\n   */\n  getUnreachablClusters() {\n    const unreachableList = [];\n    const clusters = this.clusterLatencyResults;\n\n    Object.keys(clusters).forEach((key) => {\n      const cluster = clusters[key];\n\n      if (cluster.unreachable && !cluster.reachable) {\n        unreachableList.push(key);\n      }\n    });\n\n    return unreachableList;\n  }\n\n\n  /**\n   * Attach an event handler for the icegatheringstatechange\n   * event and measure latency.\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  handleIceGatheringStateChange(peerConnection) {\n    peerConnection.onicegatheringstatechange = () => {\n      const {COMPLETE} = ICE_GATHERING_STATE;\n\n      if (peerConnection.iceConnectionState === COMPLETE) {\n        const elapsed = this.getElapsedTime(peerConnection);\n\n        LoggerProxy.logger.log(`Reachability:index#onIceGatheringStateChange --> Successfully pinged ${peerConnection.key}:`, elapsed);\n        this.setLatencyAndClose(peerConnection, elapsed);\n      }\n    };\n  }\n\n\n  /**\n   * Attach an event handler for the icecandidate\n   * event and measure latency.\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  handleOnIceCandidate(peerConnection) {\n    peerConnection.onicecandidate = (e) => {\n      const SERVER_REFLEXIVE = 'srflx';\n\n      if (e.candidate && String(e.candidate.type).toLowerCase() === SERVER_REFLEXIVE) {\n        const elapsed = this.getElapsedTime(peerConnection);\n\n        LoggerProxy.logger.log(`Reachability:index#onIceCandidate --> Successfully pinged ${peerConnection.key}:`, elapsed);\n        this.setLatencyAndClose(peerConnection, elapsed);\n      }\n    };\n  }\n\n  /**\n   * An event handler on an RTCPeerConnection when the state of the ICE\n   * candidate gathering process changes. Used to measure connection\n   * speed.\n   * @private\n   * @param {RTCPeerConnection} peerConnection\n   * @param {number} timeout\n   * @returns {Promise}\n   */\n  iceGatheringState(peerConnection, timeout) {\n    const ELAPSED = 'elapsed';\n\n    return new Promise((resolve) => {\n      const peerConnectionProxy = new window.Proxy(peerConnection, {\n        get(target, property) {\n          const targetMember = target[property];\n\n          if (typeof (targetMember) === 'function') {\n            return targetMember.bind(target);\n          }\n\n          return targetMember;\n        },\n        set: (target, property, value) => {\n          // only intercept elapsed property\n          if (property === ELAPSED) {\n            resolve({clusterId: peerConnection.key, elapsed: value});\n\n            return true;\n          }\n\n          // pass thru\n          return window.Reflect.set(target, property, value);\n        }\n      });\n\n      // Using peerConnection proxy so handle functions below\n      // won't be coupled to our promise implementation\n      this.handleIceGatheringStateChange(peerConnectionProxy);\n      this.handleOnIceCandidate(peerConnectionProxy);\n\n      // Set maximum timeout\n      window.setTimeout(() => {\n        const {CLOSED} = CONNECTION_STATE;\n\n        // Close any open peerConnections\n        if (peerConnectionProxy.connectionState !== CLOSED) {\n          this.setLatencyAndClose(peerConnectionProxy, null);\n        }\n      }, timeout);\n    });\n  }\n\n\n  /**\n   * Make a log of unreachable clusters.\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  logUnreachableClusters() {\n    const list = this.getUnreachablClusters();\n\n    list.forEach((cluster) => {\n      LoggerProxy.logger.log(`Reachability:index#logUnreachableClusters --> No ice candidate for ${cluster}.`);\n    });\n  }\n\n\n  /**\n   * Calculates time to establish connection\n   * @param {array} iceResults iceResults\n   * @returns {object} reachabilityMap\n   * @private\n   * @memberof Reachability\n   */\n  parseIceResultsToReachabilityResults(iceResults) {\n    const reachabilityMap = {};\n\n    iceResults.forEach(({clusterId, elapsed}) => {\n      let latencyResult;\n\n      if (elapsed === null) {\n        latencyResult = {reachable: 'false'};\n      }\n      else {\n        latencyResult = {\n          reachable: 'true',\n          latencyInMilliseconds: (elapsed).toString()\n        };\n      }\n\n      reachabilityMap[clusterId] = {\n        udp: latencyResult,\n        tcp: latencyResult\n      };\n    });\n\n    return reachabilityMap;\n  }\n\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {Promise<localSDPData>} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  performReachabilityCheck(clusterList) {\n    if (!clusterList || !Object.keys(clusterList).length) {\n      return Promise.resolve({});\n    }\n\n    return new Promise((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length) {\n            // TODO: handle the error condition properly and try retry\n            LoggerProxy.logger.log('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');\n            resolve({});\n          }\n          else {\n            resolve(localSDPData);\n          }\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: ${error}`);\n          resolve({});\n        });\n    });\n  }\n\n\n  /**\n   * Records latency and closes the peerConnection\n   * @param {RTCPeerConnection} peerConnection\n   * @param {number} elapsed Latency in milliseconds\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setLatencyAndClose(peerConnection, elapsed) {\n    const REACHABLE = 'reachable';\n    const UNREACHABLE = 'unreachable';\n    const {CLOSED} = CONNECTION_STATE;\n    const {key} = peerConnection;\n    const resultKey = elapsed === null ? UNREACHABLE : REACHABLE;\n    const intialState = {[REACHABLE]: 0, [UNREACHABLE]: 0};\n\n    if (peerConnection.connectionState === CLOSED) {\n      LoggerProxy.logger.log(`Reachability:index#setLatencyAndClose --> Attempting to set latency of ${elapsed} on closed peerConnection.`);\n\n      return;\n    }\n\n    this.clusterLatencyResults[key] = this.clusterLatencyResults[key] || intialState;\n    this.clusterLatencyResults[key][resultKey] += 1;\n\n    // Set to null in case this fired from\n    // an event other than onIceCandidate\n    peerConnection.onicecandidate = null;\n    peerConnection.close();\n    peerConnection.elapsed = elapsed;\n  }\n\n\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setup() {\n    this.clusterLatencyResults = {};\n  }\n}\n"],"mappings":"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"}