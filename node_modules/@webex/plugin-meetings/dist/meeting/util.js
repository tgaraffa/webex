"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _webexErrors = require("../common/errors/webex-errors");

var _metrics = _interopRequireDefault(require("../metrics"));

var _config = require("../metrics/config");

var _media = _interopRequireDefault(require("../media"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _intentToJoin = _interopRequireDefault(require("../common/errors/intent-to-join"));

var _joinMeeting = _interopRequireDefault(require("../common/errors/join-meeting"));

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _permission = _interopRequireDefault(require("../common/errors/permission"));

var _passwordError = _interopRequireDefault(require("../common/errors/password-error"));

var _captchaError = _interopRequireDefault(require("../common/errors/captcha-error"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }

var MeetingUtil = {};

MeetingUtil.parseLocusJoin = function (response) {
  var parsed = {}; // First todo: add check for existance

  parsed.locus = response.body.locus;
  parsed.mediaConnections = response.body.mediaConnections;
  parsed.locusUrl = parsed.locus.url;
  parsed.locusId = parsed.locus.url.split('/').pop();
  parsed.selfId = parsed.locus.self.id; // we need mediaId before making roap calls

  parsed.mediaConnections.forEach(function (mediaConnection) {
    if (mediaConnection.mediaId) {
      parsed.mediaId = mediaConnection.mediaId;
    }
  });
  return parsed;
};

MeetingUtil.remoteUpdateAudioVideo = function (audioMuted, videoMuted, meeting) {
  if (!meeting) {
    return _promise.default.reject(new _parameter.default('You need a meeting object.'));
  }

  var localMedias = _media.default.generateLocalMedias(meeting.mediaId, audioMuted, videoMuted);

  if ((0, _isEmpty2.default)(localMedias)) {
    return _promise.default.reject(new _parameter.default('You need a media id on the meeting to change remote audio.'));
  }

  _metrics.default.postEvent({
    event: _config.eventType.MEDIA_REQUEST,
    meeting: meeting
  });

  return meeting.meetingRequest.remoteAudioVideoToggle({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    localMedias: localMedias,
    deviceUrl: meeting.deviceUrl,
    correlationId: meeting.correlationId
  }).then(function (response) {
    _metrics.default.postEvent({
      event: _config.eventType.MEDIA_RESPONSE,
      meeting: meeting
    });

    return response.body.locus;
  });
};

MeetingUtil.hasOwner = function (info) {
  return info && info.owner;
};

MeetingUtil.isOwnerSelf = function (owner, selfId) {
  return owner === selfId;
};

MeetingUtil.isPinOrGuest = function (err) {
  var _err$body;

  return (err === null || err === void 0 ? void 0 : (_err$body = err.body) === null || _err$body === void 0 ? void 0 : _err$body.errorCode) && _constants.INTENT_TO_JOIN.includes(err.body.errorCode);
};

MeetingUtil.joinMeeting = function (meeting, options) {
  if (!meeting) {
    return _promise.default.reject(new _parameter.default('You need a meeting object.'));
  }

  _metrics.default.postEvent({
    event: _config.eventType.LOCUS_JOIN_REQUEST,
    meeting: meeting
  }); // eslint-disable-next-line no-warning-comments
  // TODO: check if the meeting is in JOINING state
  // if Joining state termintate the request as user might click multiple times


  return meeting.meetingRequest.joinMeeting({
    inviteeAddress: meeting.meetingJoinUrl || meeting.sipUri,
    meetingNumber: meeting.meetingNumber,
    deviceUrl: meeting.deviceUrl,
    locusUrl: meeting.locusUrl,
    correlationId: meeting.correlationId,
    roapMessage: options.roapMessage,
    permissionToken: meeting.permissionToken,
    resourceId: options.resourceId || null,
    moderator: options.moderator,
    pin: options.pin,
    moveToResource: options.moveToResource,
    preferTranscoding: options.preferTranscoding,
    asResourceOccupant: options.asResourceOccupant
  }).then(function (res) {
    _metrics.default.postEvent({
      event: _config.eventType.LOCUS_JOIN_RESPONSE,
      meeting: meeting,
      data: {
        trigger: _config.trigger.LOCI_UPDATE,
        locus: res.body.locus,
        mediaConnections: res.body.mediaConnections,
        trackingId: res.headers.trackingid
      }
    });

    return MeetingUtil.parseLocusJoin(res);
  });
};

MeetingUtil.cleanUp = function (meeting) {
  // make sure we send last metrics before we close the peerconnection
  var stopStatsAnalyzer = meeting.statsAnalyzer ? meeting.statsAnalyzer.stopAnalyzer() : _promise.default.resolve();
  return stopStatsAnalyzer.then(function () {
    return meeting.closeLocalStream();
  }).then(function () {
    return meeting.closeLocalShare();
  }).then(function () {
    return meeting.closeRemoteTracks();
  }).then(function () {
    return meeting.closePeerConnections();
  }).then(function () {
    meeting.unsetLocalVideoTrack();
    meeting.unsetLocalShareTrack();
    meeting.unsetRemoteTracks();
    meeting.unsetPeerConnections();
    meeting.reconnectionManager.cleanUp();
  }).then(function () {
    return meeting.roap.stop(meeting.correlationId, meeting.roapSeq);
  }).then(function () {
    return meeting.stopKeepAlive();
  });
};

MeetingUtil.disconnectPhoneAudio = function (meeting, phoneUrl) {
  if (meeting.meetingState === _constants.FULL_STATE.INACTIVE) {
    return _promise.default.reject(new _webexErrors.MeetingNotActiveError());
  }

  var options = {
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    correlationId: meeting.correlationId,
    phoneUrl: phoneUrl
  };
  return meeting.meetingRequest.disconnectPhoneAudio(options).then(function (response) {
    var _response$body;

    if (response !== null && response !== void 0 && (_response$body = response.body) !== null && _response$body !== void 0 && _response$body.locus) {
      meeting.locusInfo.onFullLocus(response.body.locus);
    }
  }).catch(function (err) {
    _loggerProxy.default.logger.error("Meeting:util#disconnectPhoneAudio --> An error occured while disconnecting phone audio in meeting ".concat(meeting.id, ", error: ").concat(err));

    return _promise.default.reject(err);
  });
}; // by default will leave on meeting's resourceId
// if you explicity want it not to leave on resource id, pass
// {resourceId: null}
// TODO: chris, you can modify this however you want


MeetingUtil.leaveMeeting = function (meeting) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (meeting.meetingState === _constants.FULL_STATE.INACTIVE) {
    // TODO: clean up if the meeting is already inactive
    return _promise.default.reject(new _webexErrors.MeetingNotActiveError());
  }

  if (MeetingUtil.isUserInLeftState(meeting.locusInfo)) {
    return _promise.default.reject(new _webexErrors.UserNotJoinedError());
  }

  var defaultOptions = {
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    correlationId: meeting.correlationId,
    resourceId: meeting.resourceId,
    deviceUrl: meeting.deviceUrl
  };

  var leaveOptions = _objectSpread(_objectSpread({}, defaultOptions), options);

  return meeting.meetingRequest.leaveMeeting(leaveOptions).then(function (response) {
    if (response && response.body && response.body.locus) {
      // && !options.moveMeeting) {
      meeting.locusInfo.onFullLocus(response.body.locus);
    }

    return _promise.default.resolve();
  }).then(function () {
    if (options.moveMeeting) {
      return _promise.default.resolve();
    }

    return MeetingUtil.cleanUp(meeting);
  }).catch(function (err) {
    // TODO: If the meeting state comes as LEFT or INACTIVE as response then
    // 1)  on leave clean up the meeting or simply do a sync on the meeting
    // 2) If the error says meeting is inactive then destroy the meeting object
    _loggerProxy.default.logger.error("Meeting:util#leaveMeeting --> An error occured while trying to leave meeting with an id of ".concat(meeting.id, ", error: ").concat(err));

    return _promise.default.reject(err);
  });
};

MeetingUtil.declineMeeting = function (meeting, reason) {
  return meeting.meetingRequest.declineMeeting({
    locusUrl: meeting.locusUrl,
    deviceUrl: meeting.deviceUrl,
    reason: reason
  });
};

MeetingUtil.isUserInLeftState = function (locusInfo) {
  var _locusInfo$parsedLocu, _locusInfo$parsedLocu2;

  return ((_locusInfo$parsedLocu = locusInfo.parsedLocus) === null || _locusInfo$parsedLocu === void 0 ? void 0 : (_locusInfo$parsedLocu2 = _locusInfo$parsedLocu.self) === null || _locusInfo$parsedLocu2 === void 0 ? void 0 : _locusInfo$parsedLocu2.state) === _constants._LEFT_;
};

MeetingUtil.isUserInIdleState = function (locusInfo) {
  var _locusInfo$parsedLocu3, _locusInfo$parsedLocu4;

  return ((_locusInfo$parsedLocu3 = locusInfo.parsedLocus) === null || _locusInfo$parsedLocu3 === void 0 ? void 0 : (_locusInfo$parsedLocu4 = _locusInfo$parsedLocu3.self) === null || _locusInfo$parsedLocu4 === void 0 ? void 0 : _locusInfo$parsedLocu4.state) === _constants._IDLE_;
};

MeetingUtil.isUserInJoinedState = function (locusInfo) {
  var _locusInfo$parsedLocu5, _locusInfo$parsedLocu6;

  return ((_locusInfo$parsedLocu5 = locusInfo.parsedLocus) === null || _locusInfo$parsedLocu5 === void 0 ? void 0 : (_locusInfo$parsedLocu6 = _locusInfo$parsedLocu5.self) === null || _locusInfo$parsedLocu6 === void 0 ? void 0 : _locusInfo$parsedLocu6.state) === _constants._JOINED_;
};

MeetingUtil.isMediaEstablished = function (currentMediaStatus) {
  return currentMediaStatus && (currentMediaStatus.audio || currentMediaStatus.video || currentMediaStatus.share);
};

MeetingUtil.joinMeetingOptions = function (meeting) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  meeting.resourceId = meeting.resourceId || options.resourceId;

  if (meeting.requiredCaptcha) {
    return _promise.default.reject(new _captchaError.default());
  }

  if (meeting.passwordStatus === _constants.PASSWORD_STATUS.REQUIRED) {
    return _promise.default.reject(new _passwordError.default());
  }

  if (options.pin) {
    _metrics.default.postEvent({
      event: _config.eventType.PIN_COLLECTED,
      meeting: meeting
    });
  } // normal join meeting, scenario A, D


  return MeetingUtil.joinMeeting(meeting, options).then(function (response) {
    meeting.setLocus(response);
    return _promise.default.resolve(response);
  }).catch(function (err) {
    // joining a claimed PMR that is not my own, scenario B
    if (MeetingUtil.isPinOrGuest(err)) {
      _metrics.default.postEvent({
        event: _config.eventType.PIN_PROMPT,
        meeting: meeting
      }); // request host pin or non host for unclaimed PMR, start of Scenario C
      // see https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-Lobby-and--IVR-Feature


      return _promise.default.reject(new _intentToJoin.default('Error Joining Meeting', err));
    }

    _loggerProxy.default.logger.error('Meeting:util#joinMeetingOptions --> Error joining the call, ', err);

    return _promise.default.reject(new _joinMeeting.default(options, 'Error Joining Meeting', err));
  });
};

MeetingUtil.updateTransceiver = function (options, meetingOptions) {
  var type = options.type,
      sendTrack = options.sendTrack,
      receiveTrack = options.receiveTrack,
      track = options.track,
      transceiver = options.transceiver,
      peerConnection = options.peerConnection,
      previousMediaDirection = options.previousMediaDirection;

  if (sendTrack !== undefined && sendTrack !== previousMediaDirection.sendTrack || receiveTrack !== undefined && receiveTrack !== previousMediaDirection.receiveTrack) {
    return _media.default.updateTransceiver({
      meetingId: meetingOptions.meeting.id,
      remoteQualityLevel: meetingOptions.mediaProperties.remoteQualityLevel,
      enableRtx: meetingOptions.meeting.config.enableRtx,
      enableExtmap: meetingOptions.meeting.config.enableExtmap
    }, peerConnection, transceiver, {
      track: track,
      type: type,
      receiveTrack: receiveTrack,
      sendTrack: sendTrack
    }).then(function () {
      return meetingOptions.meeting.roap.sendRoapMediaRequest({
        sdp: meetingOptions.mediaProperties.peerConnection.sdp,
        roapSeq: meetingOptions.meeting.roapSeq,
        meeting: meetingOptions.meeting // or can pass meeting ID

      });
    }).catch(function (e) {
      _loggerProxy.default.logger.error("Meeting:util#updateTransceiver --> Error updating the ".concat(type, " streams with error: ").concat(e));
    });
  }

  if (track) {
    transceiver.sender.replaceTrack(track);
    return _promise.default.resolve();
  }

  return _promise.default.reject(new _parameter.default('update Failed: please pass valid parameter'));
};

MeetingUtil.validateOptions = function (options) {
  var sendVideo = options.sendVideo,
      sendAudio = options.sendAudio,
      sendShare = options.sendShare,
      localStream = options.localStream,
      localShare = options.localShare;

  if (sendVideo && !MeetingUtil.getTrack(localStream).videoTrack) {
    return _promise.default.reject(new _parameter.default('please pass valid video streams'));
  }

  if (sendAudio && !MeetingUtil.getTrack(localStream).audioTrack) {
    return _promise.default.reject(new _parameter.default('please pass valid audio streams'));
  }

  if (sendShare && !MeetingUtil.getTrack(localShare).videoTrack) {
    return _promise.default.reject(new _parameter.default('please pass valid share streams'));
  }

  return _promise.default.resolve();
};

MeetingUtil.getTrack = function (stream) {
  var audioTrack = null;
  var videoTrack = null;
  var audioTracks = null;
  var videoTracks = null;

  if (!stream) {
    return {
      audioTrack: null,
      videoTrack: null
    };
  }

  if (stream.getAudioTracks) {
    audioTracks = stream.getAudioTracks();
  }

  if (stream.getVideoTracks) {
    videoTracks = stream.getVideoTracks();
  }

  if (audioTracks && audioTracks.length > 0) {
    var _audioTracks = audioTracks;

    var _audioTracks2 = (0, _slicedToArray2.default)(_audioTracks, 1);

    audioTrack = _audioTracks2[0];
  }

  if (videoTracks && videoTracks.length > 0) {
    var _videoTracks = videoTracks;

    var _videoTracks2 = (0, _slicedToArray2.default)(_videoTracks, 1);

    videoTrack = _videoTracks2[0];
  }

  return {
    audioTrack: audioTrack,
    videoTrack: videoTrack
  };
};

MeetingUtil.getModeratorFromLocusInfo = function (locusInfo) {
  return locusInfo && locusInfo.parsedLocus && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info.moderator;
};

MeetingUtil.getPolicyFromLocusInfo = function (locusInfo) {
  return locusInfo && locusInfo.parsedLocus && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info.policy;
};

MeetingUtil.getUserDisplayHintsFromLocusInfo = function (locusInfo) {
  var _locusInfo$parsedLocu7, _locusInfo$parsedLocu8;

  return (locusInfo === null || locusInfo === void 0 ? void 0 : (_locusInfo$parsedLocu7 = locusInfo.parsedLocus) === null || _locusInfo$parsedLocu7 === void 0 ? void 0 : (_locusInfo$parsedLocu8 = _locusInfo$parsedLocu7.info) === null || _locusInfo$parsedLocu8 === void 0 ? void 0 : _locusInfo$parsedLocu8.userDisplayHints) || [];
};

MeetingUtil.canInviteNewParticipants = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.ADD_GUEST);
};

MeetingUtil.canAdmitParticipant = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.ROSTER_WAITING_TO_JOIN);
};

MeetingUtil.canUserLock = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.LOCK_CONTROL_LOCK) && displayHints.includes(_constants.DISPLAY_HINTS.LOCK_STATUS_UNLOCKED);
};

MeetingUtil.canUserUnlock = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.LOCK_CONTROL_UNLOCK) && displayHints.includes(_constants.DISPLAY_HINTS.LOCK_STATUS_LOCKED);
};

MeetingUtil.canUserRecord = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.RECORDING_CONTROL_START);
};

MeetingUtil.canUserPause = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.RECORDING_CONTROL_PAUSE);
};

MeetingUtil.canUserResume = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.RECORDING_CONTROL_RESUME);
};

MeetingUtil.canUserStop = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.RECORDING_CONTROL_STOP);
};

MeetingUtil.startRecording = function (request, locusUrl, locusInfo) {
  var displayHints = MeetingUtil.getUserDisplayHintsFromLocusInfo(locusInfo);

  if (MeetingUtil.canUserRecord(displayHints)) {
    return request.recordMeeting({
      locusUrl: locusUrl,
      recording: true,
      paused: false
    });
  }

  return _promise.default.reject(new _permission.default('Start recording not allowed, due to moderator property.'));
};

MeetingUtil.pauseRecording = function (request, locusUrl, locusInfo) {
  var displayHints = MeetingUtil.getUserDisplayHintsFromLocusInfo(locusInfo);

  if (MeetingUtil.canUserPause(displayHints)) {
    return request.recordMeeting({
      locusUrl: locusUrl,
      recording: true,
      paused: true
    });
  }

  return _promise.default.reject(new _permission.default('Pause recording not allowed, due to moderator property.'));
};

MeetingUtil.resumeRecording = function (request, locusUrl, locusInfo) {
  var displayHints = MeetingUtil.getUserDisplayHintsFromLocusInfo(locusInfo);

  if (MeetingUtil.canUserResume(displayHints)) {
    return request.recordMeeting({
      locusUrl: locusUrl,
      recording: true,
      paused: false
    });
  }

  return _promise.default.reject(new _permission.default('Resume recording not allowed, due to moderator property.'));
};

MeetingUtil.stopRecording = function (request, locusUrl, locusInfo) {
  var displayHints = MeetingUtil.getUserDisplayHintsFromLocusInfo(locusInfo);

  if (MeetingUtil.canUserStop(displayHints)) {
    return request.recordMeeting({
      locusUrl: locusUrl,
      recording: false,
      paused: false
    });
  }

  return _promise.default.reject(new _permission.default('Stop recording not allowed, due to moderator property.'));
};

MeetingUtil.canUserRaiseHand = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.RAISE_HAND);
};

MeetingUtil.canUserLowerAllHands = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.LOWER_ALL_HANDS);
};

MeetingUtil.canUserLowerSomeoneElsesHand = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.LOWER_SOMEONE_ELSES_HAND);
};

MeetingUtil.lockMeeting = function (actions, request, locusUrl) {
  if (actions && actions.canLock) {
    return request.lockMeeting({
      locusUrl: locusUrl,
      lock: true
    });
  }

  return _promise.default.reject(new _permission.default('Lock not allowed, due to joined property.'));
};

MeetingUtil.unlockMeeting = function (actions, request, locusUrl) {
  if (actions && actions.canUnlock) {
    return request.lockMeeting({
      locusUrl: locusUrl,
      lock: false
    });
  }

  return _promise.default.reject(new _permission.default('Unlock not allowed, due to joined property.'));
};

MeetingUtil.handleAudioLogging = function (audioTrack) {
  var LOG_HEADER = 'MeetingUtil#handleAudioLogging -->';

  if (audioTrack) {
    var settings = audioTrack.getSettings();
    var deviceId = settings.deviceId;

    _loggerProxy.default.logger.log(LOG_HEADER, "deviceId = ".concat(deviceId));

    _loggerProxy.default.logger.log(LOG_HEADER, 'settings =', (0, _stringify.default)(settings));
  }
};

MeetingUtil.handleVideoLogging = function (videoTrack) {
  var LOG_HEADER = 'MeetingUtil#handleVideoLogging -->';

  if (videoTrack) {
    var settings = videoTrack.getSettings();
    var deviceId = settings.deviceId;

    _loggerProxy.default.logger.log(LOG_HEADER, "deviceId = ".concat(deviceId));

    _loggerProxy.default.logger.log(LOG_HEADER, 'settings =', (0, _stringify.default)(settings));
  }
};

MeetingUtil.handleDeviceLogging = function () {
  var devices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var LOG_HEADER = 'MeetingUtil#handleDeviceLogging -->';
  devices.forEach(function (device) {
    _loggerProxy.default.logger.log(LOG_HEADER, "deviceId = ".concat(device.deviceId));

    _loggerProxy.default.logger.log(LOG_HEADER, 'settings', (0, _stringify.default)(device));
  });
};

MeetingUtil.endMeetingForAll = function (meeting) {
  if (meeting.meetingState === _constants.FULL_STATE.INACTIVE) {
    return _promise.default.reject(new _webexErrors.MeetingNotActiveError());
  }

  var endOptions = {
    locusUrl: meeting.locusUrl
  };
  return meeting.meetingRequest.endMeetingForAll(endOptions).then(function (response) {
    if (response && response.body && response.body.locus) {
      meeting.locusInfo.onFullLocus(response.body.locus);
    }

    return _promise.default.resolve();
  }).then(function () {
    return MeetingUtil.cleanUp(meeting);
  }).catch(function (err) {
    _loggerProxy.default.logger.error("Meeting:util#endMeetingForAll An error occured while trying to end meeting for all with an id of ".concat(meeting.id, ", error: ").concat(err));

    return _promise.default.reject(err);
  });
};

MeetingUtil.canEnableClosedCaption = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.CAPTION_START);
};

MeetingUtil.canStartTranscribing = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.TRANSCRIPTION_CONTROL_START);
};

MeetingUtil.canStopTranscribing = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.TRANSCRIPTION_CONTROL_STOP);
};

MeetingUtil.isClosedCaptionActive = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.CAPTION_STATUS_ACTIVE);
};

MeetingUtil.isWebexAssistantActive = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.WEBEX_ASSISTANT_STATUS_ACTIVE);
};

MeetingUtil.canViewCaptionPanel = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.ENABLE_CAPTION_PANEL);
};

MeetingUtil.isRealTimeTranslationEnabled = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.DISPLAY_REAL_TIME_TRANSLATION);
};

MeetingUtil.canSelectSpokenLanguages = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.DISPLAY_NON_ENGLISH_ASR);
};

MeetingUtil.waitingForOthersToJoin = function (displayHints) {
  return displayHints.includes(_constants.DISPLAY_HINTS.WAITING_FOR_OTHERS);
};

var _default = MeetingUtil;
exports.default = _default;
//# sourceMappingURL=util.js.map
