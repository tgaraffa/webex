"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _internalMediaCore = require("@webex/internal-media-core");

var _constants = _interopRequireDefault(require("../metrics/constants"));

var _metrics = _interopRequireDefault(require("../metrics"));

var _util = _interopRequireDefault(require("../media/util"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants2 = require("../constants");

/* eslint-disable no-param-reassign */
var createEffectsState = function createEffectsState(type) {
  _loggerProxy.default.logger.info("Meeting:effectState#createEffectsState --> creating effectsState for effect ".concat(type));

  return new EffectsState(type);
};
/* The purpose of this class is to manage the effects state(for eg., BNR).
*/


var EffectsState = /*#__PURE__*/function () {
  function EffectsState(type) {
    (0, _classCallCheck2.default)(this, EffectsState);
    this.effectType = type;
    this.state = {
      bnr: {
        enabled: _constants2.BNR_STATUS.NOT_ENABLED
      },
      callToWebrtcBNRInProgress: false
    }; // these 2 hold the resolve, reject methods for the promise we returned to the client in last handleClientRequest() call

    this.pendingPromiseResolve = null;
    this.pendingPromiseReject = null;
  }
  /**
   * @memberof EffectsState
   * @param {Boolean} [isEnable] true for enableBNR, false for disableBNR request
   * @param {Object} [meeting] the meeting object
   * @returns {Promise}
   */


  (0, _createClass2.default)(EffectsState, [{
    key: "handleClientRequest",
    value: function () {
      var _handleClientRequest = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(isEnable, meeting) {
        var _this = this;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new _promise.default(function (resolve, reject) {
                  if (_this.pendingPromiseResolve) {
                    // resolve the last promise we returned to the client as the client has issued a new request that has superseded the previous one
                    _this.pendingPromiseResolve();
                  }

                  _this.pendingPromiseResolve = resolve;
                  _this.pendingPromiseReject = reject;
                  if (isEnable) _this.enableBNR(meeting);else _this.disableBNR(meeting);
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function handleClientRequest(_x, _x2) {
        return _handleClientRequest.apply(this, arguments);
      }

      return handleClientRequest;
    }()
    /**
     * Internal API to return status of BNR
     * @memberof EffectsState
     * @returns {Boolean}
     * @public
     * @memberof Meeting
     */

  }, {
    key: "isBnrEnabled",
    value: function isBnrEnabled() {
      return this.state.bnr.enabled === _constants2.BNR_STATUS.ENABLED;
    }
  }, {
    key: "resolvePromise",
    value: function resolvePromise() {
      if (this.pendingPromiseResolve) {
        this.pendingPromiseResolve(true);
      }

      this.pendingPromiseResolve = null;
      this.pendingPromiseReject = null;
    }
  }, {
    key: "rejectPromise",
    value: function rejectPromise(e) {
      if (this.pendingPromiseReject) {
        this.pendingPromiseReject(e);
      }

      this.pendingPromiseResolve = null;
      this.pendingPromiseReject = null;
    }
    /**
     * enableBNR API
     * @param {Object} meeting the meeting object
     * @returns {Promise<Boolean>}
     * @public
     * @memberof EffectsState
     */

  }, {
    key: "enableBNR",
    value: function () {
      var _enableBNR = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(meeting) {
        var bnr, audioStream;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _loggerProxy.default.logger.info('Meeting:effectState#enableBNR. Enable BNR called');

                if (!this.isBnrEnabled()) {
                  _context2.next = 4;
                  break;
                }

                _loggerProxy.default.logger.warn('Meeting:index#enableBNR. BNR is already enabled');

                return _context2.abrupt("return", this.resolvePromise());

              case 4:
                if (!this.state.callToWebrtcBNRInProgress) {
                  _context2.next = 7;
                  break;
                }

                _loggerProxy.default.logger.warn('Meeting:effectState#enableBNR. Call to WebRTC in progress, we need to wait for it to complete');

                return _context2.abrupt("return", this.resolvePromise());

              case 7:
                bnr = this.state.bnr;
                _context2.prev = 8;
                bnr.enabled = _constants2.BNR_STATUS.SHOULD_ENABLE;
                this.state.callToWebrtcBNRInProgress = true;
                audioStream = _util.default.createMediaStream([meeting.mediaProperties.audioTrack]);

                _loggerProxy.default.logger.info('Meeting:effectState#enableBNR. MediaStream created from meeting & sent to updateAudio');

                _context2.next = 15;
                return meeting.updateAudio({
                  sendAudio: true,
                  receiveAudio: meeting.mediaProperties.mediaDirection.receiveAudio,
                  stream: audioStream
                });

              case 15:
                _loggerProxy.default.logger.info('Meeting:effectState#enableBNR. Updated meeting audio with bnr enabled track');

                bnr.enabled = _constants2.BNR_STATUS.ENABLED;
                this.state.callToWebrtcBNRInProgress = false;

                _metrics.default.sendBehavioralMetric(_constants.default.ENABLE_BNR_SUCCESS);

                _context2.next = 29;
                break;

              case 21:
                _context2.prev = 21;
                _context2.t0 = _context2["catch"](8);
                bnr.enabled = _constants2.BNR_STATUS.NOT_ENABLED;
                this.state.callToWebrtcBNRInProgress = false;

                _loggerProxy.default.logger.error('Meeting:index#enableBNR.', _context2.t0);

                _metrics.default.sendBehavioralMetric(_constants.default.ENABLE_BNR_FAILURE, {
                  reason: _context2.t0.message,
                  stack: _context2.t0.stack
                });

                this.rejectPromise(_context2.t0);
                throw _context2.t0;

              case 29:
                return _context2.abrupt("return", this.resolvePromise());

              case 30:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[8, 21]]);
      }));

      function enableBNR(_x3) {
        return _enableBNR.apply(this, arguments);
      }

      return enableBNR;
    }()
    /**
     * disableBNR API
     * @param {Object} meeting the meeting object
     * @returns {Promise<Boolean>}
     * @public
     * @memberof EffectsState
     */

  }, {
    key: "disableBNR",
    value: function () {
      var _disableBNR = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(meeting) {
        var bnr, audioTrack, audioStream;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _loggerProxy.default.logger.info('Meeting:effectState#disableBNR. Disable BNR called');

                bnr = this.state.bnr;
                _context3.prev = 2;

                if (!this.state.callToWebrtcBNRInProgress) {
                  _context3.next = 6;
                  break;
                }

                _loggerProxy.default.logger.info('Meeting:effectState#disableBNR. Call to WebRTC in progress, we need to wait for it to complete');

                return _context3.abrupt("return", this.resolvePromise());

              case 6:
                bnr.enabled = _constants2.BNR_STATUS.SHOULD_DISABLE;
                this.state.callToWebrtcBNRInProgress = true;
                audioTrack = _internalMediaCore.Media.Effects.BNR.disableBNR(meeting.mediaProperties.audioTrack);
                audioStream = _util.default.createMediaStream([audioTrack]);

                _loggerProxy.default.logger.info('Meeting:effectState#disableBNR. Raw media track obtained from WebRTC & sent to updateAudio');

                _context3.next = 13;
                return meeting.updateAudio({
                  sendAudio: true,
                  receiveAudio: meeting.mediaProperties.mediaDirection.receiveAudio,
                  stream: audioStream
                });

              case 13:
                bnr.enabled = _constants2.BNR_STATUS.NOT_ENABLED;
                this.state.callToWebrtcBNRInProgress = false;

                _metrics.default.sendBehavioralMetric(_constants.default.DISABLE_BNR_SUCCESS);

                _context3.next = 26;
                break;

              case 18:
                _context3.prev = 18;
                _context3.t0 = _context3["catch"](2);
                bnr.enabled = _constants2.BNR_STATUS.ENABLED;
                this.state.callToWebrtcBNRInProgress = false;

                _loggerProxy.default.logger.error("Meeting:index#disableBNR. ".concat(_context3.t0));

                _metrics.default.sendBehavioralMetric(_constants.default.DISABLE_BNR_FAILURE, {
                  reason: _context3.t0.message,
                  stack: _context3.t0.stack
                });

                this.rejectPromise(_context3.t0);
                throw _context3.t0;

              case 26:
                return _context3.abrupt("return", this.resolvePromise());

              case 27:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 18]]);
      }));

      function disableBNR(_x4) {
        return _disableBNR.apply(this, arguments);
      }

      return disableBNR;
    }()
  }]);
  return EffectsState;
}();

var _default = createEffectsState;
exports.default = _default;
//# sourceMappingURL=effectsState.js.map
