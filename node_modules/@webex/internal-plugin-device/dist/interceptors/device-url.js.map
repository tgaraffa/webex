{"version":3,"names":["DeviceUrlInterceptor","options","headers","service","uri","webex","internal","device","services","url","CISCO_DEVICE_URL","resolve","waitForService","then","getServiceFromUrl","serviceName","name","invalidServices","includes","catch","error","message","match","reject","Interceptor"],"sources":["device-url.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\nimport {set} from 'lodash';\n\nimport {CISCO_DEVICE_URL} from '../constants';\n\n/**\n  * Adds 'cisco-device-url' header, as appropriate, to requests\n  */\nexport default class DeviceUrlInterceptor extends Interceptor {\n  /**\n   * @returns {DeviceUrlInterceptor}\n   */\n  static create() {\n    /* eslint no-invalid-this: [0] */\n    return new DeviceUrlInterceptor({webex: this});\n  }\n\n  /**\n   * @see Interceptor#onRequest\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    const {headers, service, uri} = options;\n    const {device, services} = this.webex.internal;\n\n    // Check if header is already set before moving forward\n    if (\n      !device.url ||\n      (headers && CISCO_DEVICE_URL in headers && !!headers[CISCO_DEVICE_URL])\n    ) {\n      return Promise.resolve(options);\n    }\n\n    // Wait for catalog and service to be defined.\n    return services.waitForService({service, url: uri})\n      .then((url) => {\n        // Grab the service name with the url returned from waitForService\n        const {name: serviceName} = services.getServiceFromUrl(url) || {};\n        const invalidServices = ['idbroker', 'oauth', 'saml'];\n\n        // Check if service is not one of the invalid services\n        // Assign the url to the device header\n        if (serviceName && !invalidServices.includes(serviceName)) {\n          set(options, `headers['${CISCO_DEVICE_URL}']`, device.url);\n        }\n\n        return options;\n      })\n      .catch((error) => {\n        // Validate that the error came from getServiceFromUrl\n        if (error.message.match(/was not found after waiting/)) {\n          return options;\n        }\n\n        return Promise.reject(error);\n      });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAGA;;;;;;AAEA;AACA;AACA;IACqBA,oB;;;;;;;;;;;;;IASnB;AACF;AACA;AACA;AACA;IACE,mBAAUC,OAAV,EAAmB;MACjB,IAAOC,OAAP,GAAgCD,OAAhC,CAAOC,OAAP;MAAA,IAAgBC,OAAhB,GAAgCF,OAAhC,CAAgBE,OAAhB;MAAA,IAAyBC,GAAzB,GAAgCH,OAAhC,CAAyBG,GAAzB;MACA,2BAA2B,KAAKC,KAAL,CAAWC,QAAtC;MAAA,IAAOC,MAAP,wBAAOA,MAAP;MAAA,IAAeC,QAAf,wBAAeA,QAAf,CAFiB,CAIjB;;MACA,IACE,CAACD,MAAM,CAACE,GAAR,IACCP,OAAO,IAAIQ,2BAAA,IAAoBR,OAA/B,IAA0C,CAAC,CAACA,OAAO,CAACQ,2BAAD,CAFtD,EAGE;QACA,OAAO,iBAAQC,OAAR,CAAgBV,OAAhB,CAAP;MACD,CAVgB,CAYjB;;;MACA,OAAOO,QAAQ,CAACI,cAAT,CAAwB;QAACT,OAAO,EAAPA,OAAD;QAAUM,GAAG,EAAEL;MAAf,CAAxB,EACJS,IADI,CACC,UAACJ,GAAD,EAAS;QACb;QACA,WAA4BD,QAAQ,CAACM,iBAAT,CAA2BL,GAA3B,KAAmC,EAA/D;QAAA,IAAaM,WAAb,QAAOC,IAAP;;QACA,IAAMC,eAAe,GAAG,CAAC,UAAD,EAAa,OAAb,EAAsB,MAAtB,CAAxB,CAHa,CAKb;QACA;;QACA,IAAIF,WAAW,IAAI,CAACE,eAAe,CAACC,QAAhB,CAAyBH,WAAzB,CAApB,EAA2D;UACzD,mBAAId,OAAJ,qBAAyBS,2BAAzB,SAA+CH,MAAM,CAACE,GAAtD;QACD;;QAED,OAAOR,OAAP;MACD,CAbI,EAcJkB,KAdI,CAcE,UAACC,KAAD,EAAW;QAChB;QACA,IAAIA,KAAK,CAACC,OAAN,CAAcC,KAAd,CAAoB,6BAApB,CAAJ,EAAwD;UACtD,OAAOrB,OAAP;QACD;;QAED,OAAO,iBAAQsB,MAAR,CAAeH,KAAf,CAAP;MACD,CArBI,CAAP;IAsBD;;;;IAhDD;AACF;AACA;IACE,kBAAgB;MACd;MACA,OAAO,IAAIpB,oBAAJ,CAAyB;QAACK,KAAK,EAAE;MAAR,CAAzB,CAAP;IACD;;;EAP+CmB,qB"}